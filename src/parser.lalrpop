// program -> decl_stmt
// decl_stmt -> fn_decl | struct_decl
// fn_decl -> "fn" ident (arg_list) { stmt_seq }
// struct_decl -> "struct" ident { field_list }
// stmt_seq -> stmt+
// stmt -> expr ";" | expr_stmt
// expr -> bin_expr | uni_expr | return | break | continue | literal | ident
// | "(" expr ")"
// expr_stmt -> if_expr | while_expr | local_var_decl | assignment
//
// local_var_decl -> path assignment
//
// assignment -> ident "=" expr ";"
//
// bin_expr -> expr bin_op expr
// bin_op -> "+" | "-" | "*" | "/" | "%"
//
// uni_expr -> uni_op expr
// uni_op -> "-" | "*" | "&" | "!"
//
// if_expr -> if expr { stmt_seq }
// while_expr while expr { stmt_seq }
//
// literal -> bool | number | string
// bool -> "true | "false"
//
// return -> "return" expr
// break -> "break" expr
// continue -> "continue"
// 
// path -> ident path_tail
// path_tail -> "." ident | path_tail | E

use std::str::FromStr;
use smpl_type::SmplType;
use ast::*;
use ascii::*;

grammar;

pub DeclStmt: DeclStmt = {
	<f: FnDecl> => f.into(),
	<s: StructDecl> => s.into(),
};

pub FnDecl: Function = {
	"fn" <name: Ident> "(" <args: (<FnArg> ",")*> ")" => {
		Function {
			name: name,
			args: args,
			body: unimplemented!(),
		}
	}
};

pub FnArg: FnArg = {
	<arg_type: Ident> <name: Ident> => {
		FnArg {
			name: name,
			arg_type: arg_type,
		}
	}
};

pub StructDecl: Struct = {
	"struct" <name: Ident> "{" <fields: (<StructField> ",")*> "}" => {
		Struct {
			name: name,
			body: StructBody(fields)
		}
	}
};

StructField: StructField = {
	<field_type: Ident> ":" <name: Ident> => {
		StructField {
			name: name,
			field_type: field_type,
		}
	}
};

pub Stmt: Stmt = {
	<e: Expr> ";" => Stmt::Expr(e),
	<e: ExprStmt> => Stmt::ExprStmt(e),
};

pub Block: Block = {
	"{" <s: Stmt*> "}" => Block(s)
};

pub ExprStmt: ExprStmt = {
	<if_stmt: IfStmt> => ExprStmt::If(if_stmt),
	<while_stmt: WhileStmt> => ExprStmt::While(while_stmt),
	<local_var_decl: LocalVarDecl> => ExprStmt::LocalVarDecl(local_var_decl),
	<assignment: Assignment> => ExprStmt::Assignment(assignment),
};

pub LocalVarDecl: LocalVarDecl = {
	<var_type: Path> <name: Ident> "=" <e: Expr> ";" => {
		LocalVarDecl {
			var_type: var_type,
			var_name: name,
			var_init: AstNode::untyped(e)
		}
	},
};

pub Assignment: Assignment = {
	<name: Path> "=" <e: Expr> ";" => {
		Assignment {
			name: AstNode::untyped(name),
			value: AstNode::untyped(e),
		}
	}
};

pub IfStmt: If = {
	"if" <conditional: Expr> <block: Block> => {
		If {
			conditional: AstNode::untyped(conditional),
			block: block
		}
	},
};

pub WhileStmt: While = {
	"while" <conditional: Expr> <block: Block> => {
		While {
			conditional: AstNode::untyped(conditional),
			block: block
		}
	},
};

pub Expr: Expr = {	
	<b: BinExpr> => b,
	<c: CmpExpr> => c,
};

pub CmpExpr: Expr = {
	<lhs: CmpExpr> <op: CmpOpGreaterPrecedence> <rhs: BinExpr> => {
		Expr::Bin(AstNode::untyped(BinExpr {
			op: op,
			lhs: AstNode::untyped(Box::new(lhs.into())),
			rhs: AstNode::untyped(Box::new(rhs.into())),
		}))
	},

	<lhs: CmpExpr> <op: CmpOpLowerPrecedence> <rhs: BinExpr> => {
		Expr::Bin(AstNode::untyped(BinExpr {
			op: op,
			lhs: AstNode::untyped(Box::new(lhs.into())),
			rhs: AstNode::untyped(Box::new(rhs.into())),
		}))
	},
};

pub CmpOpGreaterPrecedence: BinOp = {
	">" => BinOp::Greater,
	"<" => BinOp::Lesser,
	">=" => BinOp::GreaterEq,
	"<=" => BinOp::LesserEq,
};

pub CmpOpLowerPrecedence: BinOp = {
	"==" => BinOp::Eq,
	"!=" => BinOp::InEq,
};

pub BinExpr: Expr = {
	<lhs: BinExpr> "+" <rhs: Factor> => {
		Expr::Bin(AstNode::untyped(BinExpr {
			op: BinOp::Add,
			lhs: AstNode::untyped(Box::new(lhs.into())),
			rhs: AstNode::untyped(Box::new(rhs.into())),
		}))
	},

	<lhs: BinExpr> "-" <rhs: Factor> => {
		Expr::Bin(AstNode::untyped(BinExpr {
			op: BinOp::Sub,
			lhs: AstNode::untyped(Box::new(lhs.into())),
			rhs: AstNode::untyped(Box::new(rhs.into())),
		}))
	},

	Factor,
};

pub Factor: Expr = {
	<lhs: Factor> "*" <rhs: Term> => {
		Expr::Bin(AstNode::untyped(BinExpr {
			op: BinOp::Mul,
			lhs: AstNode::untyped(Box::new(lhs.into())),
			rhs: AstNode::untyped(Box::new(rhs)),
		}))
	},

	<lhs: Factor> "/" <rhs: Term> => {
		Expr::Bin(AstNode::untyped(BinExpr {
			op: BinOp::Div,
			lhs: AstNode::untyped(Box::new(lhs.into())),
			rhs: AstNode::untyped(Box::new(rhs)),
		}))
	},

	<lhs: Factor> "%" <rhs: Term> => {
		Expr::Bin(AstNode::untyped(BinExpr {
			op: BinOp::Mod,
			lhs: AstNode::untyped(Box::new(lhs.into())),
			rhs: AstNode::untyped(Box::new(rhs)),
		}))
	},
	<Term>
};

pub Term: Expr = {
	"(" <e: Expr> ")" => e.into(),
	<e: ExprLeaf> => e,
};

// end node rule which all other Expr related rules end in 
pub ExprLeaf: Expr = {
	"(" <u: UniExpr> ")" => Expr::Uni(AstNode::untyped(u)),
	<i: Ident> => Expr::Ident(AstNode::untyped(i)),
	<l: Literal> => Expr::Literal(l),
	<f: FnCall> => Expr::FnCall(AstNode::untyped(f)),
};

pub FnCall: FnCall = {
	<name: Ident> "(" <args: FnCallArgs?> ")" => {
		FnCall {
			name: name,
			args: args,
		}
	}
};

FnCallArgs: Vec<Expr> = {
	<first: Expr> <tail: FnCallArgsTail?> => {
		let mut a = Vec::new();
		a.push(first);
		match tail {
			None => a,
			Some(t) => {
				a.extend(t);
				a
			}
		}
	}
};

FnCallArgsTail: Vec<Expr> = {
	<args: ("," <Expr>)+> => args
};

BinOp: BinOp = {
	"+" => BinOp::Add,
	"-" => BinOp::Sub,
	"*" => BinOp::Mul,
	"/" => BinOp::Div,
	"%" => BinOp::Mod,
};

pub UniExpr: UniExpr = {
	<op: UniOp> <e: Expr> => UniExpr { op: op, expr: AstNode::untyped(Box::new(e)) },
};

pub UniOp: UniOp = {
	"-" => UniOp::Negate,
	"!" => UniOp::LogicalInvert,
	"&" => UniOp::Ref,
	"*" => UniOp::Deref,
};

pub Literal: AstNode<Literal> = {
	<number: r"[0-9]+[.[0-9]+]?"> => AstNode::untyped(Literal::Number(number.to_string())),
	"\"" <string: "r[.]*"> "\"" => AstNode::typed(Literal::String(string.to_string()), 
					SmplType::String),
};

pub Ident: Ident = {
	<ident: r"[A-Za-z][A-Za-z0-9]*"> => { Ident(AsciiString::from_str(ident).unwrap()) }
};

pub Path: Path = {
	<first: Ident> <v:("." <Ident>)*> => {
		let mut p = Vec::new();
		p.push(first);
		p.extend_from_slice(&v);
		Path(p)
	}
};

pub Keyword: Keyword = {
	"return" => Keyword::Return,
	"if" => Keyword::If,
	"while" => Keyword::While,
	"break" => Keyword::Break,
	"struct" => Keyword::Struct,
	"fn" => Keyword::Function,
};
