use ast::*;
use span::Span;
use super::tokens::*;

grammar;

extern {
	type Location = usize;
	type Error = SpannedError;

	enum Token {
		"identifier" => Token::Identifier(<String>),
		"string_literal" => Token::StringLiteral(<String>),
		"int_literal" => Token::IntLiteral(<i64>),
		"float_literal" => Token::FloatLiteral(<f64>),
		"bool_literal" => Token::BoolLiteral(<bool>),

		"fn" => Token::Fn,
		"struct" => Token::Struct,
		"mod" => Token::Mod,
		"use" => Token::Use,
		"builtin" => Token::Builtin,
		"UNCHECKED" => Token::Unchecked,

		"init" => Token::Init,

		"continue" => Token::Continue,
		"break" => Token::Break,
		"return" => Token::Return,

		"if" => Token::If,
		"else" => Token::Else,
		"elif" => Token::Elif,

		"while" => Token::While,

		"let" => Token::Let,

		"=" => Token::Assign,

		"==" => Token::Eq,
		"!=" => Token::NEq,

		">=" => Token::Gte,
		">" => Token::Gt,
		"<=" => Token::Lte,
		"<" => Token::Lt,

		"!" => Token::Invert,

		"+" => Token::Plus,
		"-" => Token::Minus,
		"*" => Token::Star,
		"/" => Token::Slash,
		"%" => Token::Percent,

		"&" => Token::Ref,

		"&&" => Token::LAnd,
		"||" => Token::LOr,

		"|>" => Token::Pipe,

		"(" => Token::LParen,
		")" => Token::RParen,
		"{" => Token::LBrace,
		"}" => Token::RBrace,
		"[" => Token::LBracket,
		"]" => Token::RBracket,

		"," => Token::Comma,
		"." => Token::Dot,

		"->" => Token::Arrow,

		":" => Token::Colon,
		"::" => Token::ColonColon,
		";" => Token::Semi,
		
		"#" => Token::Pound,
	}
}

pub Module: Module = {
	<mod_decl: ("mod" Ident ";")?> <decl: DeclStmt+> => {
		Module(mod_decl.map(|(_, ident, _)| ident), decl)
	}
};

Annotation: Annotation = {
	"#" "[" <list: KeyPairList> "]" => Annotation { keys: list },
};

KeyPairList: Vec<(Ident, Option<String>)> = {
	<head: KeyPair> "," <tail: KeyPairList> => {
		let mut v = vec![head];
		v.extend(tail);
		v
	},

	<kp: KeyPair> ","? => vec![kp],
};

KeyPair: (Ident, Option<String>) = {
	<k: "identifier"> <v: ("=" "string_literal")?> => {
		(Ident(k), v.map(|(_, literal)| literal))
	}
};

DeclStmt: DeclStmt = {
	<f: FnDecl> => DeclStmt::Function(f),
	<s: StructDecl> => DeclStmt::Struct(s),
	<u: UseDecl> => DeclStmt::Use(u),
	<bf: BuiltinFnDecl> => DeclStmt::BuiltinFunction(bf),
};

UseDecl: AstNode<UseDecl> = {
	<l: @L> "use" <i: Ident> ";" <r: @R> => AstNode::new(UseDecl(i), Span::new(l, r)),
};

pub BuiltinFnDecl: AstNode<BuiltinFunction> = {
	<annotations: Annotation*> <l: @L> "builtin" "fn" <name: Ident> "(" <params: BuiltinFnParams> ")" <return_type: ("->" TypeAnnotation)?> ";" <r: @R> => {
		AstNode::new(BuiltinFunction {
			name: name,
			params: params,
			return_type: return_type.map(|r| r.1),
			annotations: annotations,
		}, Span::new(l, r))
	}
};

BuiltinFnParams: BuiltinFnParams = {
	"UNCHECKED" => BuiltinFnParams::Unchecked,
	<params: FnParameterList?> => BuiltinFnParams::Checked(params),
};

pub FnDecl: AstNode<Function> = {
	<annotations: Annotation*> <l: @L> "fn" <name: Ident> "(" <params: FnParameterList?> ")" <return_type: ("->" TypeAnnotation)?> <b: Block> <r: @R> => {
		AstNode::new(Function {
			name: name,
			params: params,
			return_type: return_type.map(|r| r.1),
			body: b,
			annotations: annotations,
		}, Span::new(l, r))
	}
};

FnParameterList: Vec<AstNode<FnParameter>> = {
	<first: FnParameter> <tail: ("," <FnParameter>)*> => {
		let mut v = vec![first];
		v.extend(tail);
		v
	}
};

FnParameter: AstNode<FnParameter> = {
	<l: @L> <name: Ident> ":"  <param_type: TypeAnnotation> <r: @R> => {
		AstNode::new(FnParameter {
			name: name,
			param_type: param_type,
		}, Span::new(l, r))
	}
};

pub StructDecl: AstNode<Struct> = {
	<annotations: Annotation*> <l: @L> "struct" <name: Ident> "{" <fields: StructFieldList?>"}" <r: @R> => {
		AstNode::new(Struct {
			name: name,
			body: StructBody(fields),
			annotations: annotations,
		}, Span::new(l, r))
	}
};

StructFieldList: Vec<StructField> = {
	<first: StructField> "," <tail: StructFieldList> => {
		let mut v = vec![first];
		v.extend(tail);
		v
	},

	<single: StructField> ","? => {
		vec![single]
	}
};

StructField: StructField = {
	<name: Ident> ":" <field_type: TypeAnnotation> => {
		StructField {
			name: name,
			field_type: field_type,
		}
	}
};

pub Stmt: Stmt = {
	<l: @L> <e: Expr> ";" <r: @R> => Stmt::Expr(AstNode::new(e, Span::new(l, r))),
	<l: @L> <e: ExprStmt> <r: @R> => Stmt::ExprStmt(AstNode::new(e, Span::new(l, r))),
};

Block: AstNode<Block> = {
	<l: @L> "{" <rr: @R> <s: Stmt*> <lll: @L> "}" <r: @R> => {
		AstNode::new(Block(s), Span::new(l, r))
	}
};

pub ExprStmt: ExprStmt = {
	<if_stmt: IfStmt> => ExprStmt::If(if_stmt),
	<while_stmt: WhileStmt> => ExprStmt::While(while_stmt),
	<local_var_decl: LocalVarDecl> => ExprStmt::LocalVarDecl(local_var_decl),
	<assignment: Assignment> => ExprStmt::Assignment(assignment),
	<l: @L> <return_stmt: ReturnStmt> <r: @R> => ExprStmt::Return(Span::new(l, r), return_stmt),
	<l: @L> "continue" ";" <r: @R> => ExprStmt::Continue(Span::new(l, r)),
	<l: @L> "break" ";" <r: @R> => ExprStmt::Break(Span::new(l, r)),
};

ReturnStmt: Option<Expr> = {
	"return" <e: Expr?> ";" => e,
};

LocalVarDecl: LocalVarDecl = {
	"let" <name: Ident> <anno: (":" TypeAnnotation)?> "=" <e: Expr> ";" => {
		LocalVarDecl {
			var_type: anno.map(|(_, ta)| ta),
			var_name: name,
			var_init: e,
		}
	},
};

Assignment: Assignment = {
	<ll: @L> <l: @L> <name: Path> <r: @R> "=" <e: Expr> ";" <rr: @R> => {
		Assignment {
			name: AstNode::new(name, Span::new(l, r)),
			value: e,
		}
	},

	<ll: @L> <l: @L> <seg: PathSegment> <r: @R> "=" <e: Expr> ";" <rr: @R> => {
		Assignment {
			name: AstNode::new(Path(vec![seg]), Span::new(l, r)),
			value: e,
		}
	}
};

IfStmt: If = {
	"if" <initial_branch: Branch> <elifs: ("elif" Branch)*> <default_block: ("else" Block)?> => {
		let mut branches = Vec::new();
		branches.push(initial_branch);
		branches.extend(elifs.into_iter().map(|branch| branch.1));

		If {
			branches: branches,
			default_block: default_block.map(|block| block.1)
		}
		
	},
};

Branch: Branch = {
	<l: @L> <conditional: Expr> <r: @R> <block: Block> => {
		Branch {
			conditional: AstNode::new(conditional, Span::new(l, r)),
			block: block
		}
	}
};

WhileStmt: While = {
	"while" <l: @L> <conditional: Expr> <r: @R> <block: Block> => {
		While {
			conditional: AstNode::new(conditional, Span::new(l, r)),
			block: block
		}
	},
};

pub Expr: Expr = {	
	<c: TruthExpr> => c,
};

pub TruthExpr: Expr = {
	<l: @L> <lhs: TruthExpr> <op: TruthOp> <rhs: StrictEqExpr> <r: @R> => {
		Expr::Bin(AstNode::new(BinExpr {
			op: op,
			lhs: Box::new(lhs),
			rhs: Box::new(rhs),
		}, Span::new(l, r)))
	},

	<StrictEqExpr>,
};

StrictEqExpr: Expr = {
	<l: @L> <lhs: StrictEqExpr> <op: StrictEqOp> <rhs: RelativeCmpBranch> <r: @R> => {
		Expr::Bin(AstNode::new(BinExpr {
			op: op,
			lhs: Box::new(lhs),
			rhs: Box::new(rhs),
		}, Span::new(l, r)))
	},

	<RelativeCmpBranch>,
};

RelativeCmpBranch: Expr = {
	<l: @L> <lhs: MathExpr> <op: RelativeEqOp> <rhs: MathExpr> <r: @R> => {
		Expr::Bin(AstNode::new(BinExpr {
			op: op,
			lhs: Box::new(lhs),
			rhs: Box::new(rhs),
		}, Span::new(l, r)))
	},

	<MathExpr>,
};

TruthOp: BinOp = {
	"&&" => BinOp::LogicalAnd,
	"||" => BinOp::LogicalOr,
};

RelativeEqOp: BinOp = {
	">" => BinOp::Greater,
	"<" => BinOp::Lesser,
	">=" => BinOp::GreaterEq,
	"<=" => BinOp::LesserEq,
};

StrictEqOp: BinOp = {
	"==" => BinOp::Eq,
	"!=" => BinOp::InEq,
};

pub MathExpr: Expr = {
	<l: @L> <lhs: MathExpr> <op: AddOp> <rhs: Factor> <r: @R> => {
		Expr::Bin(AstNode::new(BinExpr {
			op: op,
			lhs: Box::new(lhs),
			rhs: Box::new(rhs),
		}, Span::new(l, r)))
	},

	Factor,
};

AddOp: BinOp = {
	"+" => BinOp::Add,
	"-" => BinOp::Sub,
};

Factor: Expr = {
	<l: @L> <lhs: Factor> <op: FactorOp> <rhs: UniExpr> <r: @R> => {
		Expr::Bin(AstNode::new(BinExpr {
			op: op,
			lhs: Box::new(lhs),
			rhs: Box::new(rhs),
		}, Span::new(l, r)))
	},

	<UniExpr>
};

FactorOp: BinOp = {
	"*" => BinOp::Mul,
	"/" => BinOp::Div,
	"%" => BinOp::Mod,
};


UniExpr: Expr = {
	<l: @L> <op: UniOp> <u: UniExpr> <r: @R> => Expr::Uni(AstNode::new(UniExpr { op: op, expr: Box::new(u) }, Span::new(l, r))),
	<ExprLeaf>
};

UniOp: UniOp = {
	"-" => UniOp::Negate,
	"!" => UniOp::LogicalInvert,
	"&" => UniOp::Ref,
	"*" => UniOp::Deref,
};

ExprLeaf: Expr = {
	<ExprPath>,
	<l: @L> <i: Indexing> <r: @R> => Expr::Indexing(AstNode::new(i, Span::new(l, r))),

	<Primary>,
};

ExprPath: Expr = {
	<l: @L> <path: Path> <r: @R> => Expr::FieldAccess(AstNode::new(path, Span::new(l, r))),

	<i: Ident> => Expr::Binding(i),

	<l: @L> <i: Ident> "[" <e: Expr> "]" <r: @R> => Expr::Indexing(AstNode::new(Indexing {
		array: Box::new(Expr::Binding(i)),
		indexer: Box::new(e),
	}, Span::new(l, r))),

	<l: @L> <p: ModulePath> <r: @R> => Expr::ModAccess(AstNode::new(p, Span::new(l, r))),
};

Primary: Expr = {
	<l: @L> "(" <e: Expr> ")" <r: @R> => e,
	<l: @L> <lit: Literal> <r: @R> => Expr::Literal(AstNode::new(lit, Span::new(l, r))),

	<f: FnCall> => Expr::FnCall(f),
	<l: @L> <f: FnCallChain> <r: @R> => Expr::FnCallChain(AstNode::new(f, Span::new(l, r))),

	<l: @L> <a: ArrayInit> <r: @R> => Expr::ArrayInit(AstNode::new(a, Span::new(l, r))),

	<l: @L> <struct_init: StructInit> <r: @R> => Expr::StructInit(AstNode::new(struct_init, Span::new(l, r))),

	<l: @L> <a_fn: AnonymousFn> <r: @R> => Expr::AnonymousFn(AstNode::new(a_fn, Span::new(l, r))),
};

AnonymousFn: AnonymousFn = {
	"fn" "(" <params: FnParameterList?> ")" <return_type: ("->" TypeAnnotation)?> <b: Block> => {
		AnonymousFn {
			params: params,
			return_type: return_type.map(|r| r.1),
			body: b,
		}
	}
};

Indexing: Indexing = {
	<e: Primary> "[" <i: Expr> "]" => {
		Indexing { 
			array: Box::new(e), 
			indexer: Box::new(i)
		}
	}
};

ArrayInit: ArrayInit = {
	"[" <a: ArrayInitList> "]" => ArrayInit::InitList(a),

	"[" <e: Expr> ";" <array_size: "int_literal"> "]" => {
		ArrayInit::Value(Box::new(e), array_size as u64)
	}
};

ArrayInitList: Vec<Expr> = {
	<e: Expr> "," <tail: ArrayInitList> => {
		let mut v = vec![e];
		v.extend(tail);
		v 
	},

	<e: Expr> ","? => vec![e],
};

StructInit: StructInit = {
	"init" <struct_name: ModuleBinding> "{" <init: StructFieldInitList?> "}" => {
		StructInit {
			struct_name: struct_name,
			field_init: init,
		}
	}
};

StructFieldInitList: Vec<(AstNode<Ident>, Box<Expr>)> = {
	<first: StructFieldInit> "," <tail: StructFieldInitList> => {
		let mut v = vec![first];
		v.extend(tail);
		v
	},

	<single: StructFieldInit> ","? => {
		vec![single]
	},
};

StructFieldInit: (AstNode<Ident>, Box<Expr>) = {
	<name: Ident> ":" <init: Expr> => (name, Box::new(init)),
};

FnCallChain: FnCallChain = {
	<f: FnCall> <chain: ("|>" FnCall)+> => {

		FnCallChain {
			base: f,
			chain: chain.into_iter().map(|(_, call)| call).collect(),
		}
	}
};

FnCall: AstNode<FnCall> = {
	<l: @L> <path: ModuleBinding> "(" <args: FnCallArgs?> ")" <r: @R> => {
		let path = path;
		AstNode::new(FnCall::new(
			path,
			args,
		), Span::new(l, r))
	}
};

FnCallArgs: Vec<Expr> = {
	<first: Expr> <tail: ("," <Expr>)*> => {
		let mut v = vec![first];
		v.extend(tail.into_iter());
		v
	}
};

pub Literal: Literal = {
	<Number>,
	<string: "string_literal">  => {
		Literal::String(string)
	},

	<boolean: "bool_literal"> => Literal::Bool(boolean),

};

Number: Literal = {
	<int: "int_literal"> => Literal::Int(int),
	<float: "float_literal"> => Literal::Float(float),
};

Ident: AstNode<Ident> = {
	<l: @L> <ident: "identifier"> <r: @R> => {
		AstNode::new(Ident(ident), Span::new(l, r))
	}
	
};

Path: Path = {
	<first: PathSegment> <tail: ("." <PathSegment>)+> => {
		let mut v = vec![first];
		v.extend(tail);
		Path(v)
	}
};

PathSegment: PathSegment = {
	<i: Ident> => PathSegment::Ident(i),
	<i: Ident> "[" <e: Expr> "]" => PathSegment::Indexing(i, Box::new(e)),
};

ModuleBinding: ModulePath = {
	<i: Ident> => ModulePath(vec![i]),
	<ModulePath>,
};

ModulePath: ModulePath = {
	<first: Ident> <v:("::" <Ident>)+> => {
		let mut p = Vec::new();
		p.push(first);
		p.extend_from_slice(&v);
		ModulePath(p)
	}
};

TypeAnnotation: AstNode<TypeAnnotation> = {
	<l: @L> <p: ModuleBinding> <r: @R> => AstNode::new(TypeAnnotation::Path(p), Span::new(l, r)),
	<l: @L> <a: ArrayType> <r: @R> => AstNode::new(a, Span::new(l, r)),
	<l: @L> <f: FunctionTypeAnnotation> <r: @R> => AstNode::new(f, Span::new(l, r)),
};

FunctionTypeAnnotation: TypeAnnotation = {
	"fn" "(" <p: FunctionTypeAnnotationParameterList?> ")" <r: ("->" TypeAnnotation)?> => {
		TypeAnnotation::FnType(p, r.map(|(_, t)| Box::new(t)))
	}
};

FunctionTypeAnnotationParameterList: Vec<AstNode<TypeAnnotation>> = {
	<first: TypeAnnotation> <tail: FunctionTypeAnnotationParameterList> => {
		let mut v = vec![first];
		v.extend(tail);
		v
	},

	<t: TypeAnnotation> ","? => vec![t],

	
};

ArrayType: TypeAnnotation = {
	"[" <t: TypeAnnotation> ";" <number: "int_literal"> "]" => {
		TypeAnnotation::Array(Box::new(t), number as u64)
	}
};
