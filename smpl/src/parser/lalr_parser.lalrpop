/// --------------SMPL Grammar----------------
///
///
/// module -> mod_decl? decl_stmt+
///	mod_decl -> "mod" ident;
/// decl_stmt -> fn_decl | struct_decl | use_decl
///
///	use_decl -> "use" ident ";"
///
/// fn_decl -> "fn" ident "(" [param_list]? ")" ["->" type_annotation]? block
/// param_list -> param ["," param]*
/// param -> ident ":" type_annotation
///
///
/// struct_decl -> "struct" ident "{" struct_field_list "}"
/// struct_field_list -> struct_field "," struct_field_list
///		      -> struct_field ","?
/// struct_field -> ident ":" type_annotation
///
///
/// block -> "{" [stmt]*  "}"
/// stmt -> expr ";" | expr_stmt
///
///
/// expr_stmt -> if_stmt | while_stmt | local_var_decl | assignment
/// if_stmt -> "if" expr block
/// while_stmt -> "while" expr block
/// local_var_decl -> "let" ident ":" type_annotation "=" expr ";"
/// assignment -> path "=" expr ";"
///
///
/// expr -> truth_expr
///
/// truth_expr -> truth_expr ["&&" | "||"] strict_eq_expr | strict_eq_expr
/// strict_eq_expr -> strict_eq_expr ["==" | "!="] relative_cmp_expr | relative_cmp_expr
/// relative_cmp_expr -> math_expr [">" | ">=" | "<" | "<="] math_expr | math_expr
///
/// math_expr -> math_expr ["+" | "-"] factor | factor
/// factor -> factor ["*" | "/" | "%"] uni_expr | uni_expr
///
/// uni_expr -> ["-" | "!" | "&" | "*"] uni_expr | expr_leaf
///
/// expr_leaf -> "(" expr ")"| literal | fn_call | path | struct_init
///
/// struct_init -> "init" type_path "{" struct_field_init_list "}"
/// struct_field_init_list -> struct_field_init "," struct_field_init_list
///		      -> struct_field_init ","?
/// struct_field_init -> ident ":" expr 
/// 
/// literal -> "true" | "false" | [0-9]+[.[0.9]+]? | "[[:ASCII:]]"
///
///
/// fn_call -> ModulePath "(" fn_call_args ")"
/// fn_call_args -> expr ["," expr]*
///
/// ident -> [a-zA-Z_] [a-zA-Z0-9_]*
/// path -> ident ["." ident]*
/// type_path -> ident ["." ident]*

use std::str::FromStr;
use ast::*;
use ascii::*;

grammar;

/// module -> mod_decl? decl_stmt+
/// mod_decl -> "mod" ident ";"
pub Module: Module = {
	<mod_decl: ("mod" Ident ";")?> <decl: DeclStmt+> => {
		Module(mod_decl.map(|(_, ident, _)| ident), decl)
	}
};

/// decl_stmt -> fn_decl | struct_decl | use_decl
DeclStmt: DeclStmt = {
	<f: FnDecl> => f.into(),
	<s: StructDecl> => s.into(),
	<u: UseDecl> => DeclStmt::Use(u),
};

UseDecl: UseDecl = {
	"use" <i: Ident> ";" => UseDecl(i),
};

/// fn_decl -> "fn" ident "(" [param_list]? ")" ["->" type_annotation]? block
pub FnDecl: Function = {
	"fn" <name: Ident> "(" <params: FnParameterList?> ")" <return_type: ("->" TypeAnnotation)?> <b: Block> => {
		Function::new(
			name,
			params,
			return_type.map(|r| r.1),
			b,
		)
	}
};

/// param_list -> param ["," param]*
FnParameterList: Vec<FnParameter> = {
	<first: FnParameter> <tail: ("," <FnParameter>)*> => {
		let mut v = vec![first];
		v.extend(tail);
		v
	}
};

/// param -> ident ":" type_annotation
FnParameter: FnParameter = {
	<name: Ident> ":"  <param_type: TypeAnnotation> => {
		FnParameter::new(name, param_type)
	}
};

/// struct_decl -> "struct" ident "{" struct_field_list "}"
pub StructDecl: Struct = {
	"struct" <name: Ident> "{" <fields: StructFieldList?>"}" => {
		Struct {
			name: name,
			body: StructBody(fields)
		}
	}
};

/// struct_decl -> "struct" ident "{" struct_field_list "}"
/// struct_field_list -> struct_field "," struct_field_list
///		      -> struct_field ","?
/// struct_field -> ident ":" path
StructFieldList: Vec<StructField> = {
	<first: StructField> "," <tail: StructFieldList> => {
		let mut v = vec![first];
		v.extend(tail);
		v
	},

	<single: StructField> ","? => {
		vec![single]
	}
};

/// struct_field -> ident ":" type_annotation
StructField: StructField = {
	<name: Ident> ":" <field_type: TypeAnnotation> => {
		StructField {
			name: name,
			field_type: field_type,
		}
	}
};

/// stmt -> expr ";" | expr_stmt
pub Stmt: Stmt = {
	<e: Expr> ";" => Stmt::Expr(e),
	<e: ExprStmt> => Stmt::ExprStmt(e),
};

/// block -> "{" [stmt]*  "}"
Block: Block = {
	"{" <s: Stmt*> "}" => Block(s)
};

/// expr_stmt -> if_stmt | while_stmt | local_var_decl | assignment
pub ExprStmt: ExprStmt = {
	<if_stmt: IfStmt> => ExprStmt::If(if_stmt),
	<while_stmt: WhileStmt> => ExprStmt::While(while_stmt),
	<local_var_decl: LocalVarDecl> => ExprStmt::LocalVarDecl(local_var_decl),
	<assignment: Assignment> => ExprStmt::Assignment(assignment),
	<return_stmt: ReturnStmt> => ExprStmt::Return(return_stmt),
	"continue;" => ExprStmt::Continue,
	"break;" => ExprStmt::Break,
};

/// return -> "return" expr ";"
ReturnStmt: Option<Expr> = {
	"return" <e: Expr?> ";" => e,
};

/// local_var_decl -> "let" ident ":" type_annotation  "=" expr ";"
LocalVarDecl: LocalVarDecl = {
	"let" <name: Ident> ":" <var_type: TypeAnnotation> "=" <e: Expr> ";" => {
		LocalVarDecl::new(
			var_type,
			name,
			e,
		)
	},
};

/// assignment -> path "=" expr ";"
Assignment: Assignment = {
	<name: Path> "=" <e: Expr> ";" => {
		Assignment::new(
			name,
			e,
		)
	}
};

/// if_stmt -> "if" branch ["elif" branch]* ["else" block]?
IfStmt: If = {
	"if" <initial_branch: Branch> <elifs: ("elif" Branch)*> <default_block: ("else" Block)?> => {
		let mut branches = Vec::new();
		branches.push(initial_branch);
		branches.extend(elifs.into_iter().map(|branch| branch.1));

		If {
			branches: branches,
			default_block: default_block.map(|block| block.1)
		}
		
	},
};

/// branch -> expr block
Branch: Branch = {
	<conditional: Expr> <block: Block> => {
		Branch {
			conditional: conditional,
			block: block
		}
	}
};

/// while_stmt -> "while" expr block
WhileStmt: While = {
	"while" <conditional: Expr> <block: Block> => {
		While {
			conditional: conditional,
			block: block
		}
	},
};

/// expr -> truth_expr
pub Expr: Expr = {	
	<c: TruthExpr> => c,
};

/// truth_expr -> truth_expr ["&&" | "||"] strict_eq_expr | strict_eq_expr
pub TruthExpr: Expr = {
	<lhs: TruthExpr> <op: TruthOp> <rhs: StrictEqExpr> => {
		Expr::Bin(BinExpr {
			op: op,
			lhs: Box::new(lhs),
			rhs: Box::new(rhs),
		})
	},

	<StrictEqExpr>,
};

/// strict_eq_expr -> strict_eq_expr ["==" | "!="] relative_cmp_expr | relative_cmp_expr
StrictEqExpr: Expr = {
	<lhs: StrictEqExpr> <op: StrictEqOp> <rhs: RelativeCmpBranch> => {
		Expr::Bin(BinExpr {
			op: op,
			lhs: Box::new(lhs),
			rhs: Box::new(rhs),
		})
	},

	<RelativeCmpBranch>,
};

/// relative_cmp_expr -> math_expr [">" | ">=" | "<" | "<="] math_expr | math_expr
RelativeCmpBranch: Expr = {
	<lhs: MathExpr> <op: RelativeEqOp> <rhs: MathExpr> => {
		Expr::Bin(BinExpr {
			op: op,
			lhs: Box::new(lhs),
			rhs: Box::new(rhs),
		})
	},

	<MathExpr>,
};

TruthOp: BinOp = {
	"&&" => BinOp::LogicalAnd,
	"||" => BinOp::LogicalOr,
};

RelativeEqOp: BinOp = {
	">" => BinOp::Greater,
	"<" => BinOp::Lesser,
	">=" => BinOp::GreaterEq,
	"<=" => BinOp::LesserEq,
};

StrictEqOp: BinOp = {
	"==" => BinOp::Eq,
	"!=" => BinOp::InEq,
};

/// math_expr -> math_expr ["+" | "-"] factor | factor
pub MathExpr: Expr = {
	<lhs: MathExpr> <op: AddOp> <rhs: Factor> => {
		Expr::Bin(BinExpr {
			op: op,
			lhs: Box::new(lhs),
			rhs: Box::new(rhs),
		})
	},

	Factor,
};

AddOp: BinOp = {
	"+" => BinOp::Add,
	"-" => BinOp::Sub,
};

/// factor -> factor ["*" | "/" | "%"] uni_expr | uni_expr
Factor: Expr = {
	<lhs: Factor> <op: FactorOp> <rhs: UniExpr> => {
		Expr::Bin(BinExpr {
			op: op,
			lhs: Box::new(lhs),
			rhs: Box::new(rhs),
		})
	},

	<UniExpr>
};

FactorOp: BinOp = {
	"*" => BinOp::Mul,
	"/" => BinOp::Div,
	"%" => BinOp::Mod,
};


/// uni_expr -> ["-" | "!" | "&" | "*"] uni_expr | expr_leaf
UniExpr: Expr = {
	<op: UniOp> <u: UniExpr> => Expr::Uni(UniExpr { op: op, expr: Box::new(u) }),
	<ExprLeaf>
};

UniOp: UniOp = {
	"-" => UniOp::Negate,
	"!" => UniOp::LogicalInvert,
	"&" => UniOp::Ref,
	"*" => UniOp::Deref,
};

/// expr_leaf -> "(" expr ")"| literal | fn_call | path | struct_init
ExprLeaf: Expr = {
	<path: Path> => {
		let mut path = path;
		if path.0.len() == 1 {
			let segment = path.0.pop().unwrap();
			match segment {
				PathSegment::Ident(i) => Expr::Variable(i),
				PathSegment::Indexing(i, e) => {
					let i = Indexing {
						array: Box::new(Expr::Variable(i)),
						indexer: e
					};
					Expr::Indexing(i)
				}
			}
		} else {
			Expr::FieldAccess(path)
		}
	},

	<i: Indexing> => Expr::Indexing(i),

	<Primary>,
};

Primary: Expr = {
	"(" <e: Expr> ")" => e,
	<l: Literal> => Expr::Literal(l),
	<f: FnCall> => Expr::FnCall(f),

	<a: ArrayInit> => Expr::ArrayInit(a),

	<struct_init: StructInit> => Expr::StructInit(struct_init),
};

Indexing: Indexing = {
	<e: Primary> "[" <i: Expr> "]" => {
		Indexing { 
			array: Box::new(e), 
			indexer: Box::new(i)
		}
	}
};

ArrayInit: ArrayInit = {
	"[" <a: ArrayInitList> "]" => ArrayInit::InitList(a),

	"[" <e: Expr> ";" <n: Number> "]" => {
		let array_size = n.parse::<u64>().unwrap();
		ArrayInit::Value(Box::new(e), array_size)
	}
};

ArrayInitList: Vec<Expr> = {
	<e: Expr> "," <tail: ArrayInitList> => {
		let mut v = vec![e];
		v.extend(tail);
		v 
	},

	<e: Expr> ","? => vec![e],
};

/// struct_init -> "init" type_path "{" struct_field_init_list "}"
StructInit: StructInit = {
	"init" <struct_name: ModulePath> "{" <init: StructFieldInitList?> "}" => {
		StructInit {
			struct_name: struct_name,
			field_init: init,
		}
	}
};

/// struct_field_init_list -> struct_field_init "," struct_field_init_list
///		      -> struct_field_init ","?
/// struct_field_init -> ident ":" expr 
StructFieldInitList: Vec<(Ident, Box<Expr>)> = {
	<first: StructFieldInit> "," <tail: StructFieldInitList> => {
		let mut v = vec![first];
		v.extend(tail);
		v
	},

	<single: StructFieldInit> ","? => {
		vec![single]
	},
};

StructFieldInit: (Ident, Box<Expr>) = {
	<name: Ident> ":" <init: Expr> => (name, Box::new(init)),
};

/// fn_call -> ModulePath "(" fn_call_args ")"
FnCall: FnCall = {
	<path: ModulePath> "(" <args: FnCallArgs?> ")" => {
		let mut path = path;
		FnCall::new(
			path,
			args,
		)
	}
};

/// fn_call_args -> expr ["," expr]*
FnCallArgs: Vec<Expr> = {
	<first: Expr> <tail: ("," <Expr>)*> => {
		let mut v = vec![first];
		v.extend(tail.into_iter());
		v
	}
};

/// literal -> "true" | "false" | [0-9]+[.[0.9]+]? | "[[:ASCII:]]"
pub Literal: Literal = {
	<number: Number> => {
		if number.contains(".") {
			Literal::Float(number.parse::<f64>().unwrap())
		} else {
			Literal::Int(number.parse::<i64>().unwrap())
		}
	},
	<string: r##"".*""##>  => {
		let mut string = AsciiString::from_str(string).unwrap();
		string.remove(0);
		string.pop();
		Literal::String(string)
	},
	"true" => Literal::Bool(true),
	"false" => Literal::Bool(false), 

};

Number: String = {
	<number: r"[-]?[0-9]+[.[0-9]*]?"> => number.to_string(),
};

/// ident -> [a-zA-Z_] [a-zA-Z0-9_]*
Ident: Ident = {
	<ident: r"[A-Za-z_][_A-Za-z0-9]*"> => { Ident(AsciiString::from_str(ident).unwrap()) }
};

/// path -> ident ["." ident]*
Path: Path = {
	<p: PathSegmentList> => Path(p),
};

PathSegmentList: Vec<PathSegment> = {
	<first: PathSegment> "." <tail: PathSegmentList> => {
		let mut p = tail;
		p.insert(0, first);
		p
	},

	<segment: PathSegment> => vec![segment],
};

PathSegment: PathSegment = {
	<i: Ident> => PathSegment::Ident(i),
	<i: Ident> "[" <e: Expr> "]" => PathSegment::Indexing(i, Box::new(e)),
};

/// type_path -> ident ["." ident]*
ModulePath: ModulePath = {
	<first: Ident> <v:("::" <Ident>)*> => {
		let mut p = Vec::new();
		p.push(first);
		p.extend_from_slice(&v);
		ModulePath(p)
	}
};

TypeAnnotation: TypeAnnotation = {
	<p: ModulePath> => TypeAnnotation::Path(p),
	<ArrayType>,
	<FunctionTypeAnnotation>,
};

FunctionTypeAnnotation: TypeAnnotation = {
	"Fn" "(" <p: FunctionTypeAnnotationParameterList?> ")" <r: ("->" TypeAnnotation)?> => {
		TypeAnnotation::FnType(p, r.map(|(_, t)| Box::new(t)))
	}
};

FunctionTypeAnnotationParameterList: Vec<TypeAnnotation> = {
	<first: TypeAnnotation> <tail: FunctionTypeAnnotationParameterList> => {
		let mut v = vec![first];
		v.extend(tail);
		v
	},

	<t: TypeAnnotation> ","? => vec![t],

	
};

ArrayType: TypeAnnotation = {
	"[" <t: TypeAnnotation> ";" <number: Number> "]" => {
		let number = number.parse::<u64>().unwrap();
		TypeAnnotation::Array(Box::new(t), number)
	}
};
