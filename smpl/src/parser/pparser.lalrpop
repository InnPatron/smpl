use crate::ast::{self, Ident};
use crate::ast_node::AstNode;
use crate::expr_ast;
use crate::span::Span;
use super::error;
use super::tokens::{self, Token};

grammar;

pub Module: ast::Module = {
    <mod_decl: ModDecl?> <top_levels: TopLevel*> => {
        ast::Module {
            mod_name: mod_decl,
            decls: vec![],
        }
    }
};

ModDecl: AstNode<Ident> = {
    MOD <l: @L> <n: IDENT> <r: @R> SEMI => {

        let ident = match n {
            Token::Ident(i) => i,
            _ => unreachable!(),
        };

        AstNode::new(ident, Span::new(l, r))
    }
};

// TODO: annotation prefix to the declarations
TopLevel: ast::Decl = {
    <import: Import> SEMI => ast::Decl::Import(import),
    <export: Export> SEMI => ast::Decl::Export(export),

    <opaque: Opaque> SEMI => ast::Decl::Opaque(opaque),

    <struct_decl: StructDecl> => ast::Decl::Struct(struct_decl),

    <func: BuiltinFnDecl> SEMI => ast::Decl::BuiltinFn(func),
};

BuiltinFnDecl: AstNode<ast::BuiltinFnDecl> = {
    <l: @L> BUILTIN FN <nl: @L> <name: IDENT> <nr: @R> <type_params: TypeParams?> <params: BuiltinFnParams> <return_type: (ARROW TypeAnn)?> <r: @R> => {
        let return_type = return_type.map(|rt| rt.1);
        let type_params = type_params.unwrap_or(ast::TypeParams { params: Vec::new() });
        ast_node!(ast::BuiltinFnDecl {
            name: ast_node!(ident!(name).into(), nl, nr),
            params,
            return_type,
            type_params,
            annotations: Vec::new(),
            where_clause: None,
        }, l, r)
    }
};

BuiltinFnParams: ast::BuiltinFnParams = {
    "(" UNCHECKED ")" => ast::BuiltinFnParams::Unchecked,
    <params: FnParams> => ast::BuiltinFnParams::Checked(params),
};

FnParams: Vec<AstNode<ast::FnParam>> = {
    "(" <list: FnParamList?> ")" => list.unwrap_or(Vec::new()),
};

FnParamList: Vec<AstNode<ast::FnParam>> = {
    <p: FnParam> COMMA <mut rest: FnParamList> => {
        rest.insert(0, p);
        rest
    },

    <p: FnParam> COMMA? => vec![p],
};

FnParam: AstNode<ast::FnParam> = {
    <nl: @L> <p: IDENT> <nr: @R>  COLON <ann: TypeAnn>  <rr: @R> => {
        ast_node!(ast::FnParam {
            name: ast_node!(ident!(p).into(), nl, rr),
            param_type: ann,
        }, nl, rr)
    }
};

// TODO: Where clause
StructDecl: AstNode<ast::Struct> = {
    <l: @L> STRUCT <nl: @L> <name: IDENT> <nr: @R> <type_params: TypeParams?> "{" <body: StructFieldList> "}" <r: @R> => {
        let type_params = type_params.unwrap_or(ast::TypeParams { params: Vec::new() });
        ast_node!(ast::Struct {
            name: ast_node!(ident!(name).into(), nl, nr),
            body,
            annotations: Vec::new(),
            type_params,
            where_clause: None,
        }, l, r)
    }
};

StructFieldList: Vec<ast::StructField> = {
    <f: StructField> COMMA <mut rest: StructFieldList> => {
        rest.insert(0, f);
        rest
    },

    <f: StructField> COMMA? => {
        vec![f]
    },
};

StructField: ast::StructField = {
    <nl: @L> <f: IDENT> <nr: @R> COLON <ann: TypeAnn> => {
        ast::StructField {
            name: ast_node!(ident!(f), nl, nr),
            field_type: ann,
        }
    }
};

TypeAnn: AstNode<ast::TypeAnn> = {
    <l: @L> <tp: TypedPath> <r: @R> => ast_node!(ast::TypeAnn::Path(tp), l, r),
    <l: @L> <ft: FnType> <r: @R> => ast_node!(ast::TypeAnn::FnType(ft), l, r),
};

FnType: AstNode<ast::FnType> = {
    <l: @L> FN "(" <params: TypeArgsList?> ")" ARROW <return_type: TypeAnn?> <r: @R> => {
        let params = params.unwrap_or(Vec::new());
        let return_type = return_type.map(|rt| Box::new(rt));
        ast_node!(ast::FnType {
            params,
            return_type,
        }, l, r)
    }
}

TypedPath: AstNode<ast::TypedPath> = {
    <l: @L> <base: ModulePath> <args: TypeArgs?> <r: @R> => {
        let args = args.unwrap_or(Vec::new());
        ast_node!(ast::TypedPath {
            base,
            args
        }, l, r)
    }
};

TypeArgs: Vec<AstNode<ast::TypeAnn>> = {
    "[" <l: TypeArgsList>  "]" => l,
};

TypeArgsList: Vec<AstNode<ast::TypeAnn>> = {
   <t: TypeAnn> COMMA <mut rest: TypeArgsList> => {
        rest.insert(0, t);
        rest
    },

    <t: TypeAnn> COMMA? => vec![t],
};

ModulePath: AstNode<ast::ModulePath> = {
    <l: @L> <i: IDENT> <r: @R> COLONCOLON <rest: ModulePath> <rr: @R> => {
        let (mut data, _) = rest.into_data();
        data.0.insert(0, ast_node!(ident!(i).into(), l, r));
        ast_node!(data, l, rr)
    },

    <l: @L> <i: IDENT> <r: @R> => {
        ast_node!(ast::ModulePath(vec![ast_node!(ident!(i).into(), l, r)]), l, r)
    },
};


// TODO: Where clause
Opaque: AstNode<ast::Opaque> = {
    <l: @L> OPAQUE <nl: @L> <name: IDENT><nr: @R> <type_params: TypeParams?> <r: @R>=> {
        ast_node!(ast::Opaque {
            name: ast_node!(ast::Name::from(ident!(name)), nl, nr),
            annotations: Vec::new(),
            type_params,
            where_clause: None,
        }, l, r)
    }
};

TypeParams: ast::TypeParams = {
     "[" <tps: TypeParamList> "]" => ast::TypeParams { params: tps },
};

TypeParamList: Vec<AstNode<ast::Name>> = {
    <l: @L> <tp: IDENT> <r: @R> COMMA <mut rest: TypeParamList> => {
        rest.insert(0, ast_node!(ident!(tp).into(), l, r));
        rest
    },

    <l: @L> <tp: IDENT> <r: @R> COMMA? => vec![ast_node!(ident!(tp).into(), l, r)],
};

Export: AstNode<ast::ExportDecl> = {
    // export all from module [except { List<ModuleItemData> }]?
    <l: @L> EXPORT ALL FROM <ml: @L> <module: IDENT> <mr: @R> <except: (EXCEPT "{" ModuleItemDataList "}")?> <r: @R> => {
        let except: Vec<AstNode<ast::ModuleItemData>> = except.map(|e| e.2)
            .unwrap_or(Vec::new());
        ast_node!(ast::ExportDecl::ExportAll {
            from_module: Some(ast_node!(ident!(module), ml, mr)),
            except,
        }, l, r)
    },

    // TODO: unify when locations can be extracted within non-top-levels
    // export all [except { List<ModuleItemData> }]?
    <l: @L> EXPORT ALL <except: (EXCEPT "{" ModuleItemDataList "}")?> <r: @R>=> {
        let except: Vec<AstNode<ast::ModuleItemData>> = except.map(|e| e.2)
            .unwrap_or(Vec::new());
        ast_node!(ast::ExportDecl::ExportAll {
            from_module: None,
            except,
        }, l, r)
    },

    // export from module { List<ModuleItemData> }
    <l: @L> EXPORT FROM <ml: @L> <module: IDENT> <mr: @R> "{" <items: ModuleItemDataList > "}" <r: @R> => {
        ast_node!(ast::ExportDecl::ExportItems {
            from_module: Some(ast_node!(ident!(module), ml, mr)),
            items,
        }, l, r)
    },

    // export { List<ModuleItemData> }
    <l: @L> EXPORT "{" <items: ModuleItemDataList> "{" <r: @R> => {
        ast_node!(ast::ExportDecl::ExportItems {
            from_module: None,
            items,
        }, l, r)
    },
};

Import: AstNode<ast::ImportDecl> = {

    // import module { List<module-item-data> } from module
    <il: @L> IMPORT "{" <items: ModuleItemDataList> "}" FROM <ml: @L> <module: IDENT> <mr: @R> => {
        ast_node!(ast::ImportDecl::ImportItems {
            module: ast_node!(ident!(module), ml, mr),
            items,
        }, il, mr)
    },

    // import module
    <l: @L> IMPORT <ml: @L> <module: IDENT> <mr: @R> => {
        ast_node!(ast::ImportDecl::ImportModule {
            module: ast_node!(ident!(module), ml, mr),
            alias: None,
        }, l, mr)
    },

    // TODO: combine with the other rule somehow?
    // import module as module_alias
    <l: @L> IMPORT <ml: @L> <module: IDENT> <mr: @R> AS <l2: @L> <alias: IDENT> <r2: @R> => {
        ast_node!(ast::ImportDecl::ImportModule {
            module: ast_node!(ident!(module), ml, mr),
            alias: Some(ast_node!(ident!(alias), l2, r2)),
        }, l, r2)
    },

    // import all from module [except { List<module-item-data> }]?
    <l: @L> IMPORT ALL FROM <ml: @L> <module: IDENT> <mr: @R> <except: (EXCEPT "{" ModuleItemDataList "}")?> <r: @R>=> {
        let except: Vec<AstNode<ast::ModuleItemData>> = except.map(|e| e.2)
            .unwrap_or(Vec::new());
        ast_node!(ast::ImportDecl::ImportAll {
            module: ast_node!(ident!(module), ml, mr),
            except,
        }, l, mr)
    },
};

ModuleItemDataList: Vec<AstNode<ast::ModuleItemData>> = {
    // ModuleItemData , ModuleItemDataList
    <d: ModuleItemData> COMMA <mut rest: ModuleItemDataList> => {
        rest.insert(0, d);
        rest
    },

    // ModuleItemData [,]?
    <d: ModuleItemData> COMMA? => vec![d],
};

ModuleItemData: AstNode<ast::ModuleItemData> = {
    // item as item_alias
    <l1: @L> <item: IDENT> <r1: @R> AS <l2: @L> <alias: IDENT?> <r2: @R> => {
        ast_node!(ast::ModuleItemData {
            original_name: AstNode::new(ident!(item), Span::new(l1, r1)),
            name_override: alias.map(|i| AstNode::new(ident!(i), Span::new(l2, r2))),
        }, l1, r2)
    },

    // item
    <l: @L> <item: IDENT> <r: @R> => {
        ast_node!(ast::ModuleItemData {
            original_name: ast_node!(ident!(item), l, r),
            name_override: None,
        }, l, r)
    },
};

extern {
    type Location = usize;
    type Error = error::TokenizerError;

    enum tokens::Token {
        IDENT => tokens::Token::Ident(..),

        STRING => tokens::Token::StringLiteral(..),
        INT => tokens::Token::IntLiteral(..),
        FLOAT => tokens::Token::FloatLiteral(..),
        BOOL => tokens::Token::BoolLiteral(..),

        FN => tokens::Token::Fn,
        STRUCT => tokens::Token::Struct,
        OPAQUE => tokens::Token::Opaque,
        MOD => tokens::Token::Mod,
        USE => tokens::Token::Use,
        BUILTIN => tokens::Token::Builtin,
        UNCHECKED => tokens::Token::Unchecked,
        TYPE => tokens::Token::Type,
        WHERE => tokens::Token::Where,
        COMMA => tokens::Token::Comma,
        ARROW => tokens::Token::Arrow,
        COLON => tokens::Token::Colon,
        COLONCOLON => tokens::Token::ColonColon,
        SEMI => tokens::Token::Semi,
        POUND => tokens::Token::Pound,
        BASE => tokens::Token::Base,

        IMPORT => tokens::Token::Import,
        EXPORT => tokens::Token::Export,
        EXCEPT => tokens::Token::Except,
        FROM => tokens::Token::From,
        ALL => tokens::Token::All,
        AS => tokens::Token::As,

        INIT => tokens::Token::Init,
        EXTRACT => tokens::Token::Extract,
        CONTINUE => tokens::Token::Continue,
        BREAK => tokens::Token::Break,
        RETURN => tokens::Token::Return,
        IF => tokens::Token::If,
        ELSE => tokens::Token::Else,
        ELIF => tokens::Token::Elif,
        WHILE => tokens::Token::While,
        LET => tokens::Token::Let,
        EQEQ => tokens::Token::EqEq,
        BANGEQ => tokens::Token::BangEq,
        EQ => tokens::Token::Eq,
        DOT => tokens::Token::Dot,
        AT => tokens::Token::At,
        AMP => tokens::Token::Amp,
        PIPE => tokens::Token::Pipe,
        BANG => tokens::Token::Bang,
        AND => tokens::Token::And,
        OR => tokens::Token::Or,
        "(" => tokens::Token::LParen,
        ")" => tokens::Token::RParen,
        "[" => tokens::Token::LBracket,
        "]" => tokens::Token::RBracket,
        "{" => tokens::Token::LBrace,
        "}" => tokens::Token::RBrace,
    }
}
