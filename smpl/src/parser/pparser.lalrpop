use crate::ast::{self, Ident};
use crate::ast_node::AstNode;
use crate::expr_ast as east;
use crate::span::Span;
use super::error;
use super::tokens::{self, Token};

grammar;

pub Module: ast::Module = {
    <mod_decl: ModDecl?> <top_levels: TopLevel*> => {
        ast::Module {
            mod_name: mod_decl,
            decls: vec![],
        }
    }
};

ModDecl: AstNode<Ident> = {
    MOD <l: @L> <n: IDENT> <r: @R> SEMI => {

        let ident = match n {
            Token::Ident(i) => i,
            _ => unreachable!(),
        };

        AstNode::new(ident, Span::new(l, r))
    }
};

// TODO: annotation prefix to the declarations
TopLevel: ast::Decl = {
    <import: Import> SEMI => ast::Decl::Import(import),
    <export: Export> SEMI => ast::Decl::Export(export),

    <opaque: Opaque> SEMI => ast::Decl::Opaque(opaque),

    <struct_decl: StructDecl> => ast::Decl::Struct(struct_decl),

    <func: BuiltinFnDecl> SEMI => ast::Decl::BuiltinFn(func),

    <func: FnDecl> => ast::Decl::Fn(func),
};

FnDecl: AstNode<ast::FnDecl> = {
    <l: @L> FN <nl: @L> <name: IDENT> <nr: @R> <type_params: TypeParams?> <params: FnParams> <return_type: (ARROW TypeAnn)?>  <body: Block> <r: @R> => {
        let return_type = return_type.map(|rt| rt.1);
        let type_params = type_params.unwrap_or(ast::TypeParams { params: Vec::new() });
        ast_node!(ast::FnDecl {
            name: ast_node!(ident!(name).into(), nl, nr),
            params,
            return_type,
            type_params,
            body,
            annotations: Vec::new(),
            where_clause: None,
        }, l, r)
    }
};

BuiltinFnDecl: AstNode<ast::BuiltinFnDecl> = {
    <l: @L> BUILTIN FN <nl: @L> <name: IDENT> <nr: @R> <type_params: TypeParams?> <params: BuiltinFnParams> <return_type: (ARROW TypeAnn)?> <r: @R> => {
        let return_type = return_type.map(|rt| rt.1);
        let type_params = type_params.unwrap_or(ast::TypeParams { params: Vec::new() });
        ast_node!(ast::BuiltinFnDecl {
            name: ast_node!(ident!(name).into(), nl, nr),
            params,
            return_type,
            type_params,
            annotations: Vec::new(),
            where_clause: None,
        }, l, r)
    }
};

BuiltinFnParams: ast::BuiltinFnParams = {
    "(" UNCHECKED ")" => ast::BuiltinFnParams::Unchecked,
    <params: FnParams> => ast::BuiltinFnParams::Checked(params),
};

FnParams: Vec<AstNode<ast::FnParam>> = {
    "(" <list: FnParamList?> ")" => list.unwrap_or(Vec::new()),
};

FnParamList: Vec<AstNode<ast::FnParam>> = {
    <p: FnParam> COMMA <mut rest: FnParamList> => {
        rest.insert(0, p);
        rest
    },

    <p: FnParam> COMMA? => vec![p],
};

FnParam: AstNode<ast::FnParam> = {
    <nl: @L> <p: IDENT> <nr: @R>  COLON <ann: TypeAnn>  <rr: @R> => {
        ast_node!(ast::FnParam {
            name: ast_node!(ident!(p).into(), nl, rr),
            param_type: ann,
        }, nl, rr)
    }
};

// TODO: Where clause
StructDecl: AstNode<ast::Struct> = {
    <l: @L> STRUCT <nl: @L> <name: IDENT> <nr: @R> <type_params: TypeParams?> "{" <body: StructFieldList> "}" <r: @R> => {
        let type_params = type_params.unwrap_or(ast::TypeParams { params: Vec::new() });
        ast_node!(ast::Struct {
            name: ast_node!(ident!(name).into(), nl, nr),
            body,
            annotations: Vec::new(),
            type_params,
            where_clause: None,
        }, l, r)
    }
};

StructFieldList: Vec<ast::StructField> = {
    <f: StructField> COMMA <mut rest: StructFieldList> => {
        rest.insert(0, f);
        rest
    },

    <f: StructField> COMMA? => {
        vec![f]
    },
};

StructField: ast::StructField = {
    <nl: @L> <f: IDENT> <nr: @R> COLON <ann: TypeAnn> => {
        ast::StructField {
            name: ast_node!(ident!(f), nl, nr),
            field_type: ann,
        }
    }
};

TypeAnn: AstNode<ast::TypeAnn> = {
    <l: @L> <tp: TypedPath> <r: @R> => ast_node!(ast::TypeAnn::Path(tp), l, r),
    <l: @L> <ft: FnType> <r: @R> => ast_node!(ast::TypeAnn::FnType(ft), l, r),
};

FnType: AstNode<ast::FnType> = {
    <l: @L> FN "(" <params: TypeArgsList?> ")" ARROW <return_type: TypeAnn> <r: @R> => {
        let params = params.unwrap_or(Vec::new());
        let return_type = Some(Box::new(return_type));
        ast_node!(ast::FnType {
            params,
            return_type,
        }, l, r)
    }
}

TypedPath: AstNode<ast::TypedPath> = {
    <l: @L> <base: ModulePath> <args: TypeArgs?> <r: @R> => {
        let args = args.unwrap_or(Vec::new());
        ast_node!(ast::TypedPath {
            base,
            args
        }, l, r)
    }
};

TypeArgs: Vec<AstNode<ast::TypeAnn>> = {
    "[" <l: TypeArgsList>  "]" => l,
};

TypeArgsList: Vec<AstNode<ast::TypeAnn>> = {
   <t: TypeAnn> COMMA <mut rest: TypeArgsList> => {
        rest.insert(0, t);
        rest
    },

    <t: TypeAnn> COMMA? => vec![t],
};

ModulePath: AstNode<ast::ModulePath> = {
    <l: @L> <i: IDENT> <r: @R> COLONCOLON <rest: ModulePath> <rr: @R> => {
        let (mut data, _) = rest.into_data();
        data.0.insert(0, ast_node!(ident!(i).into(), l, r));
        ast_node!(data, l, rr)
    },

    <l: @L> <i: IDENT> <r: @R> => {
        ast_node!(ast::ModulePath(vec![ast_node!(ident!(i).into(), l, r)]), l, r)
    },
};


// TODO: Where clause
Opaque: AstNode<ast::Opaque> = {
    <l: @L> OPAQUE <nl: @L> <name: IDENT><nr: @R> <type_params: TypeParams?> <r: @R>=> {
        ast_node!(ast::Opaque {
            name: ast_node!(ast::Name::from(ident!(name)), nl, nr),
            annotations: Vec::new(),
            type_params,
            where_clause: None,
        }, l, r)
    }
};

TypeParams: ast::TypeParams = {
     "[" <tps: TypeParamList> "]" => ast::TypeParams { params: tps },
};

TypeParamList: Vec<AstNode<ast::Name>> = {
    <l: @L> <tp: IDENT> <r: @R> COMMA <mut rest: TypeParamList> => {
        rest.insert(0, ast_node!(ident!(tp).into(), l, r));
        rest
    },

    <l: @L> <tp: IDENT> <r: @R> COMMA? => vec![ast_node!(ident!(tp).into(), l, r)],
};

Export: AstNode<ast::ExportDecl> = {
    // export all from module [except { List<ModuleItemData> }]?
    <l: @L> EXPORT ALL FROM <ml: @L> <module: IDENT> <mr: @R> <except: (EXCEPT "{" ModuleItemDataList "}")?> <r: @R> => {
        let except: Vec<AstNode<ast::ModuleItemData>> = except.map(|e| e.2)
            .unwrap_or(Vec::new());
        ast_node!(ast::ExportDecl::ExportAll {
            from_module: Some(ast_node!(ident!(module), ml, mr)),
            except,
        }, l, r)
    },

    // TODO: unify when locations can be extracted within non-top-levels
    // export all [except { List<ModuleItemData> }]?
    <l: @L> EXPORT ALL <except: (EXCEPT "{" ModuleItemDataList "}")?> <r: @R>=> {
        let except: Vec<AstNode<ast::ModuleItemData>> = except.map(|e| e.2)
            .unwrap_or(Vec::new());
        ast_node!(ast::ExportDecl::ExportAll {
            from_module: None,
            except,
        }, l, r)
    },

    // export from module { List<ModuleItemData> }
    <l: @L> EXPORT FROM <ml: @L> <module: IDENT> <mr: @R> "{" <items: ModuleItemDataList > "}" <r: @R> => {
        ast_node!(ast::ExportDecl::ExportItems {
            from_module: Some(ast_node!(ident!(module), ml, mr)),
            items,
        }, l, r)
    },

    // export { List<ModuleItemData> }
    <l: @L> EXPORT "{" <items: ModuleItemDataList> "{" <r: @R> => {
        ast_node!(ast::ExportDecl::ExportItems {
            from_module: None,
            items,
        }, l, r)
    },
};

Import: AstNode<ast::ImportDecl> = {

    // import module { List<module-item-data> } from module
    <il: @L> IMPORT "{" <items: ModuleItemDataList> "}" FROM <ml: @L> <module: IDENT> <mr: @R> => {
        ast_node!(ast::ImportDecl::ImportItems {
            module: ast_node!(ident!(module), ml, mr),
            items,
        }, il, mr)
    },

    // import module
    <l: @L> IMPORT <ml: @L> <module: IDENT> <mr: @R> => {
        ast_node!(ast::ImportDecl::ImportModule {
            module: ast_node!(ident!(module), ml, mr),
            alias: None,
        }, l, mr)
    },

    // TODO: combine with the other rule somehow?
    // import module as module_alias
    <l: @L> IMPORT <ml: @L> <module: IDENT> <mr: @R> AS <l2: @L> <alias: IDENT> <r2: @R> => {
        ast_node!(ast::ImportDecl::ImportModule {
            module: ast_node!(ident!(module), ml, mr),
            alias: Some(ast_node!(ident!(alias), l2, r2)),
        }, l, r2)
    },

    // import all from module [except { List<module-item-data> }]?
    <l: @L> IMPORT ALL FROM <ml: @L> <module: IDENT> <mr: @R> <except: (EXCEPT "{" ModuleItemDataList "}")?> <r: @R>=> {
        let except: Vec<AstNode<ast::ModuleItemData>> = except.map(|e| e.2)
            .unwrap_or(Vec::new());
        ast_node!(ast::ImportDecl::ImportAll {
            module: ast_node!(ident!(module), ml, mr),
            except,
        }, l, mr)
    },
};

ModuleItemDataList: Vec<AstNode<ast::ModuleItemData>> = {
    // ModuleItemData , ModuleItemDataList
    <d: ModuleItemData> COMMA <mut rest: ModuleItemDataList> => {
        rest.insert(0, d);
        rest
    },

    // ModuleItemData [,]?
    <d: ModuleItemData> COMMA? => vec![d],
};

ModuleItemData: AstNode<ast::ModuleItemData> = {
    // item as item_alias
    <l1: @L> <item: IDENT> <r1: @R> AS <l2: @L> <alias: IDENT?> <r2: @R> => {
        ast_node!(ast::ModuleItemData {
            original_name: AstNode::new(ident!(item), Span::new(l1, r1)),
            name_override: alias.map(|i| AstNode::new(ident!(i), Span::new(l2, r2))),
        }, l1, r2)
    },

    // item
    <l: @L> <item: IDENT> <r: @R> => {
        ast_node!(ast::ModuleItemData {
            original_name: ast_node!(ident!(item), l, r),
            name_override: None,
        }, l, r)
    },
};

// exprs / stmts
Block: AstNode<east::Block> = {
    <l: @L> "{" <stmts: Stmt*> "}" <r: @R> => ast_node!(east::Block(stmts), l, r),
};

Stmt: east::Stmt = {
    <if_stmt: IfExpr> => east::Stmt::If(if_stmt),

    <while_stmt: WhileExpr> => east::Stmt::While(while_stmt),

    <let_stmt: LetStmt> => east::Stmt::Let(let_stmt),

    <l: @L> RETURN <e: Expr?> SEMI <r: @R> => east::Stmt::Return(ast_node!(e, l ,r)),

    <l: @L> CONTINUE SEMI <r: @R> => east::Stmt::Continue(ast_node!((), l, r)),

    <l: @L> BREAK <e: Expr?> SEMI <r: @R> => east::Stmt::Break(ast_node!(e, l, r)),

    <l: @L> EXTRACT <e: Expr?> SEMI <r: @R> => east::Stmt::Extract(ast_node!(e, l, r)),

    <expr_stmt: Expr> SEMI => east::Stmt::ExprStmt(expr_stmt),

    <b: Block> => east::Stmt::Block(b),
};

// TODO: add patterns
LetStmt: AstNode<east::LetStmt> = {
    <l: @L> LET <pl: @L> <name: IDENT> <pr: @R> <type_ann: (COLON TypeAnn)?> EQ <init: Expr> SEMI <r: @R> => {
        ast_node!(east::LetStmt {
            name: ast_node!(ident!(name).into(), pl, pr),
            type_ann: type_ann.map(|ta| ta.1),
            init,
        }, l, r)
    }
};

Expr: east::Expr = {

    <b: Block> => east::Expr::Block(b),

    <if_expr: IfExpr> => east::Expr::If(Box::new(if_expr)),

    <while_expr: WhileExpr> => east::Expr::While(Box::new(while_expr)),

    InfixExpr,
}

InfixExpr: east::Expr = {

    <lambda: Lambda> => east::Expr::Lambda(lambda),

    // TODO: parse bin-expr

    AppExpr,
}

AppExpr: east::Expr = {

    <fn_call: FnCall> => east::Expr::FnCall(fn_call),

    <uni_expr: UniExpr> => east::Expr::Uni(uni_expr),

    ExprLeaf
};

ExprLeaf: east::Expr = {

    <literal: Literal> => east::Expr::Literal(literal),

    <path: TypedPath> => east::Expr::Path(path),

    <init: StructInit> => east::Expr::StructInit(init),

    <dot_access: DotAccess> => east::Expr::DotAccess(dot_access),

    // underscore (only usable as immediate children of fn calls)
    <l: @L> UNDERSCORE <r: @R> => east::Expr::Underscore(ast_node!((), l, r)),

    "(" <e: Expr> ")" => e,
};

DotAccess: AstNode<east::DotAccess> = {
    <root: ExprLeaf> DOT <rest: IDENT> => todo!(),
};

Lambda: AstNode<east::Lambda> = {
    <l: @L> LAM <params: FnParams> <return_type: (ARROW TypeAnn)?> COLON <body: Expr> <r: @R> => {
        ast_node!(east::Lambda {
            body: Box::new(body),
            params,
            return_type: return_type.map(|rt| rt.1),
        }, l, r)
    }
};

StructInit: AstNode<east::StructInit> = {
    <l: @L> INIT <struct_name: TypedPath?> "{" <init: StructFieldInitList?> "}" <r: @R> => {
        let field_init = init.unwrap_or(Vec::new());
        ast_node!(east::StructInit {
            struct_name,
            field_init: field_init,
        }, l, r)
    },
};

StructFieldInitList: Vec<(AstNode<ast::Ident>, Box<east::Expr>)> = {
    <init: StructFieldInit> COMMA <mut rest: StructFieldInitList> => {
        rest.insert(0, init);
        rest
    },

    <init: StructFieldInit> COMMA => vec![init],
};

StructFieldInit: (AstNode<ast::Ident>, Box<east::Expr>) = {
    <l: @L> <field: IDENT> <r: @R> COLON <e: Expr> => {
        (ast_node!(ident!(field), l, r), Box::new(e))
    }
};

FnCall: AstNode<east::FnCall> = {
    <l: @L> <func: ExprLeaf> "("<list: ArgList?> ")" <r: @R> => {
        let func = Box::new(func);
        let args = list.unwrap_or(Vec::new());
        ast_node!(east::FnCall {
            func,
            args,
        }, l, r)
    },
};

ArgList: Vec<east::Expr> = {
    <e: Expr> COMMA <mut rest: ArgList> => {
        rest.insert(0, e);
        rest
    },

    <e: Expr> COMMA? => vec![e],
}

UniExpr: AstNode<east::UniExpr> = {
    <l: @L> <op: UniOp> <expr: AppExpr> <r: @R> => {
        ast_node!(east::UniExpr {
            op,
            expr: Box::new(expr),
        }, l, r)
    }
};

UniOp: east::UniOp = {
    AMP => east::UniOp::Ref,
    AT => east::UniOp::Deref,
    BANG => east::UniOp::Not,
};

Literal: AstNode<east::Literal> = {
    <l: @L> <literal: STRING> <r: @R> => ast_node!(east::Literal::String(literal_data!(literal)), l, r),

    <l: @L> <literal: FLOAT> <r: @R> => ast_node!(east::Literal::Float(literal_data!(literal)), l, r),

    <l: @L> <literal: INT> <r: @R> => ast_node!(east::Literal::Int(literal_data!(literal)), l, r),

    <l: @L> <literal: BOOL> <r: @R> => {
        match literal {
            tokens::Token::BoolLiteral(literal) => ast_node!(east::Literal::Bool(literal), l, r),
            _ => unreachable!(),
        }
    }
};

WhileExpr: AstNode<east::While> = {
    <l: @L> WHILE <main_cond: Expr> <body: Block>  <elifs: (ELIF Expr Block)*> <default_branch: (ELSE Block)?> <r: @R> => {

        let branches = elifs.into_iter().map(|elif|
            east::Branch {
                condition: elif.1,
                block: elif.2,
            }).collect();
        let default_branch = default_branch.map(|e| e.1);

        ast_node!(east::While {
            condition: main_cond,
            body,
            branches,
            default_branch,
        }, l, r)
    }
};

IfExpr: AstNode<east::If> = {
    <l: @L> IF <main_cond: Expr> <main_branch: Block> <elifs: (ELIF Expr Block)*> <default_branch: (ELSE Block)?> <r: @R> => {

        let elifs = elifs.into_iter().map(|elif|
            east::Branch {
                condition: elif.1,
                block: elif.2,
            });
        let main_branch = east::Branch {
            condition: main_cond,
            block: main_branch,
        };
        let default_branch = default_branch.map(|e| e.1);
        let branches = std::iter::once(main_branch).chain(elifs).collect();

        ast_node!(east::If {
            branches,
            default_branch,
        }, l, r)
    }
};

extern {
    type Location = usize;
    type Error = error::TokenizerError;

    enum tokens::Token {
        IDENT => tokens::Token::Ident(..),

        STRING => tokens::Token::StringLiteral(..),
        INT => tokens::Token::IntLiteral(..),
        FLOAT => tokens::Token::FloatLiteral(..),
        BOOL => tokens::Token::BoolLiteral(..),

        FN => tokens::Token::Fn,
        STRUCT => tokens::Token::Struct,
        OPAQUE => tokens::Token::Opaque,
        MOD => tokens::Token::Mod,
        USE => tokens::Token::Use,
        BUILTIN => tokens::Token::Builtin,
        UNCHECKED => tokens::Token::Unchecked,
        TYPE => tokens::Token::Type,
        WHERE => tokens::Token::Where,
        COMMA => tokens::Token::Comma,
        ARROW => tokens::Token::Arrow,
        COLON => tokens::Token::Colon,
        COLONCOLON => tokens::Token::ColonColon,
        SEMI => tokens::Token::Semi,
        POUND => tokens::Token::Pound,
        BASE => tokens::Token::Base,

        IMPORT => tokens::Token::Import,
        EXPORT => tokens::Token::Export,
        EXCEPT => tokens::Token::Except,
        FROM => tokens::Token::From,
        ALL => tokens::Token::All,
        AS => tokens::Token::As,

        INIT => tokens::Token::Init,
        LAM => tokens::Token::Lam,
        UNDERSCORE => tokens::Token::Underscore,
        EXTRACT => tokens::Token::Extract,
        CONTINUE => tokens::Token::Continue,
        BREAK => tokens::Token::Break,
        RETURN => tokens::Token::Return,
        IF => tokens::Token::If,
        ELSE => tokens::Token::Else,
        ELIF => tokens::Token::Elif,
        WHILE => tokens::Token::While,
        LET => tokens::Token::Let,
        EQEQ => tokens::Token::EqEq,
        BANGEQ => tokens::Token::BangEq,
        EQ => tokens::Token::Eq,
        DOT => tokens::Token::Dot,
        AT => tokens::Token::At,
        AMP => tokens::Token::Amp,
        PIPE => tokens::Token::Pipe,
        BANG => tokens::Token::Bang,
        AND => tokens::Token::And,
        OR => tokens::Token::Or,
        "(" => tokens::Token::LParen,
        ")" => tokens::Token::RParen,
        "[" => tokens::Token::LBracket,
        "]" => tokens::Token::RBracket,
        "{" => tokens::Token::LBrace,
        "}" => tokens::Token::RBrace,
    }
}
