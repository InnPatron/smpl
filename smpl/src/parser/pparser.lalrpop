use crate::ast::{self, Ident};
use crate::ast_node::AstNode;
use crate::expr_ast;
use crate::span::Span;
use super::error;
use super::tokens::{self, Token};

grammar;

pub Module: ast::Module = {
    <mod_decl: ModDecl?> <top_levels: TopLevel*> => {
        ast::Module {
            mod_name: mod_decl,
            decls: vec![],
        }
    }
};

ModDecl: AstNode<Ident> = {
    MOD <l: @L> <n: IDENT> <r: @R> SEMI => {

        let ident = match n {
            Token::Ident(i) => i,
            _ => unreachable!(),
        };

        AstNode::new(ident, Span::new(l, r))
    }
};

TopLevel: ast::Decl = {
    <import: Import> SEMI => ast::Decl::Import(import),
    <export: Export> SEMI => ast::Decl::Export(export),
};

Export: AstNode<ast::ExportDecl> = {
    // export all from module [except { List<ModuleItemData> }]?
    <l: @L> EXPORT ALL FROM <ml: @L> <module: IDENT> <mr: @R> <except: (EXCEPT "{" ModuleItemDataList "}")?> <r: @R> => {
        let except: Vec<AstNode<ast::ModuleItemData>> = except.map(|e| e.2)
            .unwrap_or(Vec::new());
        ast_node!(ast::ExportDecl::ExportAll {
            from_module: Some(ast_node!(ident!(module), ml, mr)),
            except,
        }, l, r)
    },

    // TODO: unify when locations can be extracted within non-top-levels
    // export all [except { List<ModuleItemData> }]?
    <l: @L> EXPORT ALL <except: (EXCEPT "{" ModuleItemDataList "}")?> <r: @R>=> {
        let except: Vec<AstNode<ast::ModuleItemData>> = except.map(|e| e.2)
            .unwrap_or(Vec::new());
        ast_node!(ast::ExportDecl::ExportAll {
            from_module: None,
            except,
        }, l, r)
    },

    // export from module { List<ModuleItemData> }
    <l: @L> EXPORT FROM <ml: @L> <module: IDENT> <mr: @R> "{" <items: ModuleItemDataList > "}" <r: @R> => {
        ast_node!(ast::ExportDecl::ExportItems {
            from_module: Some(ast_node!(ident!(module), ml, mr)),
            items,
        }, l, r)
    },

    // export { List<ModuleItemData> }
    <l: @L> EXPORT "{" <items: ModuleItemDataList> "{" <r: @R> => {
        ast_node!(ast::ExportDecl::ExportItems {
            from_module: None,
            items,
        }, l, r)
    },
};

Import: AstNode<ast::ImportDecl> = {

    // import module { List<module-item-data> } from module
    <il: @L> IMPORT "{" <items: ModuleItemDataList> "}" FROM <ml: @L> <module: IDENT> <mr: @R> => {
        ast_node!(ast::ImportDecl::ImportItems {
            module: ast_node!(ident!(module), ml, mr),
            items,
        }, il, mr)
    },

    // import module
    <l: @L> IMPORT <ml: @L> <module: IDENT> <mr: @R> => {
        ast_node!(ast::ImportDecl::ImportModule {
            module: ast_node!(ident!(module), ml, mr),
            alias: None,
        }, l, mr)
    },

    // TODO: combine with the other rule somehow?
    // import module as module_alias
    <l: @L> IMPORT <ml: @L> <module: IDENT> <mr: @R> AS <l2: @L> <alias: IDENT> <r2: @R> => {
        ast_node!(ast::ImportDecl::ImportModule {
            module: ast_node!(ident!(module), ml, mr),
            alias: Some(ast_node!(ident!(alias), l2, r2)),
        }, l, r2)
    },

    // import all from module [except { List<module-item-data> }]?
    <l: @L> IMPORT ALL FROM <ml: @L> <module: IDENT> <mr: @R> <except: (EXCEPT "{" ModuleItemDataList "}")?> <r: @R>=> {
        let except: Vec<AstNode<ast::ModuleItemData>> = except.map(|e| e.2)
            .unwrap_or(Vec::new());
        ast_node!(ast::ImportDecl::ImportAll {
            module: ast_node!(ident!(module), ml, mr),
            except,
        }, l, mr)
    },
};

ModuleItemDataList: Vec<AstNode<ast::ModuleItemData>> = {
    // ModuleItemData , ModuleItemDataList
    <d: ModuleItemData> COMMA <mut rest: ModuleItemDataList> => {
        rest.insert(0, d);
        rest
    },

    // ModuleItemData [,]?
    <d: ModuleItemData> COMMA? => vec![d],
};

ModuleItemData: AstNode<ast::ModuleItemData> = {
    // item as item_alias
    <l1: @L> <item: IDENT> <r1: @R> AS <l2: @L> <alias: IDENT?> <r2: @R> => {
        ast_node!(ast::ModuleItemData {
            original_name: AstNode::new(ident!(item), Span::new(l1, r1)),
            name_override: alias.map(|i| AstNode::new(ident!(i), Span::new(l2, r2))),
        }, l1, r2)
    },

    // item
    <l: @L> <item: IDENT> <r: @R> => {
        ast_node!(ast::ModuleItemData {
            original_name: ast_node!(ident!(item), l, r),
            name_override: None,
        }, l, r)
    },
};

extern {
    type Location = usize;
    type Error = error::TokenizerError;

    enum tokens::Token {
        IDENT => tokens::Token::Ident(..),

        STRING => tokens::Token::StringLiteral(..),
        INT => tokens::Token::IntLiteral(..),
        FLOAT => tokens::Token::FloatLiteral(..),
        BOOL => tokens::Token::BoolLiteral(..),

        FN => tokens::Token::Fn,
        STRUCT => tokens::Token::Struct,
        OPAQUE => tokens::Token::Opaque,
        MOD => tokens::Token::Mod,
        USE => tokens::Token::Use,
        BUILTIN => tokens::Token::Builtin,
        UNCHECKED => tokens::Token::Unchecked,
        TYPE => tokens::Token::Type,
        WHERE => tokens::Token::Where,
        COMMA => tokens::Token::Comma,
        ARROW => tokens::Token::Arrow,
        COLON => tokens::Token::Colon,
        COLONCOLON => tokens::Token::ColonColon,
        SEMI => tokens::Token::Semi,
        POUND => tokens::Token::Pound,
        BASE => tokens::Token::Base,

        IMPORT => tokens::Token::Import,
        EXPORT => tokens::Token::Export,
        EXCEPT => tokens::Token::Except,
        FROM => tokens::Token::From,
        ALL => tokens::Token::All,
        AS => tokens::Token::As,

        INIT => tokens::Token::Init,
        EXTRACT => tokens::Token::Extract,
        CONTINUE => tokens::Token::Continue,
        BREAK => tokens::Token::Break,
        RETURN => tokens::Token::Return,
        IF => tokens::Token::If,
        ELSE => tokens::Token::Else,
        ELIF => tokens::Token::Elif,
        WHILE => tokens::Token::While,
        LET => tokens::Token::Let,
        EQEQ => tokens::Token::EqEq,
        BANGEQ => tokens::Token::BangEq,
        EQ => tokens::Token::Eq,
        DOT => tokens::Token::Dot,
        AT => tokens::Token::At,
        AMP => tokens::Token::Amp,
        PIPE => tokens::Token::Pipe,
        BANG => tokens::Token::Bang,
        AND => tokens::Token::And,
        OR => tokens::Token::Or,
        "(" => tokens::Token::LParen,
        ")" => tokens::Token::RParen,
        "[" => tokens::Token::LBracket,
        "]" => tokens::Token::RBracket,
        "{" => tokens::Token::LBrace,
        "}" => tokens::Token::RBrace,
    }
}
