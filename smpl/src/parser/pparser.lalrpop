use std::collections::HashMap;

use crate::ast;
use crate::ast_node::AstNode;
use crate::expr_ast as east;
use crate::span::Span;
use super::error;
use super::tokens::{self, Token};

grammar;

pub CodeUnit: ast::CodeUnit = {
    <m: Module> => ast::CodeUnit::Module(m),
    <ms: ModSig> => ast::CodeUnit::ModSig(ms),
};

pub ModSig: ast::ModSig = {
    <l: @L> SIG <nl: @L>  <n: IDENT> <nr: @R> SEMI <imports: (Import SEMI)*> <members: ModSigMember*> <r: @R> => {
        let imports = imports.into_iter().map(|(i, _)| i).collect();
        ast::ModSig {
            name: ast_node!(ident!(n).into(), nl, nr),
            members,
            imports,
        }
    },
};


ModSigMember: AstNode<ast::SigMember> = {
    <l: @L> TYPE <nl: @L> <n: IDENT> <nr: @R> SEMI <r: @R> => {
        ast_node!(ast::SigMember::Type(ast_node!(ident!(n).into(), nl, nr)), l, r)
    },

    <l: @L> MVAL <nl: @L> <n: IDENT> <nr: @R> COLON <ann: TypeAnn> SEMI <r: @R> => {
        ast_node!(ast::SigMember::Value {
            name: ast_node!(ident!(n), nl, nr),
            ann,
        }, l, r)
    },
};

pub Module: ast::Module = {
    <mod_decl: ModDecl?> <top_levels: TopLevel*> => {
        ast::Module {
            mod_decl,
            decls: top_levels,
        }
    }
};

ModDecl: AstNode<ast::ModDecl> = {
    <l: @L> MOD <nl: @L> <n: IDENT> <nr: @R> <mod_params: ModParams?> <sig_decl: ModSigBlock?> SEMI <r: @R> => {

        let mod_params = mod_params.unwrap_or(vec![]);
        let declared_sigs = sig_decl.unwrap_or(vec![]);

        ast_node!(ast::ModDecl {
            mod_name: ast_node!(ident!(n), nl, nr),
            mod_params,
            declared_sigs,
        }, l, r)
    },
};

ModSigBlock: Vec<AstNode<ast::Name>> = {
    IMPL "{" "}" => vec![],
    IMPL "{" <list: DeclaredSigList> "}" => list,
};

DeclaredSigList: Vec<AstNode<ast::Name>> = {
    <l: @L> <sig: IDENT> <r: @R> COMMA <mut rest: DeclaredSigList> => {
        rest.insert(0, ast_node!(ident!(sig).into(), l, r));
        rest
    },

    <l: @L> <sig: IDENT> <r: @R> => vec![ast_node!(ident!(sig).into(), l, r)],
};

ModParams: Vec<AstNode<ast::ModParam>> = {
    "(" ")" => vec![],
    "(" <list: ModParamList> ")" => list,
};

ModParamList: Vec<AstNode<ast::ModParam>> = {
    <first: ModParam> COMMA <mut rest: ModParamList> => {
        rest.insert(0, first);
        rest
    },

    <mp: ModParam> => vec![mp],
};

ModParam: AstNode<ast::ModParam> = {
    <l: @L> <name: IDENT> <nr: @R> COLON <sigs: ModSigList> <r: @R> => {
        ast_node!(ast::ModParam {
            name: ast_node!(ident!(name).into(), l, nr),
            sigs,
        }, l, r)
    }
};

ModSigList: Vec<AstNode<ast::SigConstraint>> = {
    <l: @L> <first: SigConstraint> <r: @R> PLUS <mut rest: ModSigList> => {
        rest.insert(0, ast_node!(first, l, r));
        rest
    },

    <l: @L> <sig: SigConstraint> <r: @R> => vec![ast_node!(sig, l, r)],
};

SigConstraint: ast::SigConstraint = {
    <id: Ident> => ast::SigConstraint {
        name: id.into(),
        constraints: HashMap::new(),
    },
};

// TODO: annotation prefix to the declarations
TopLevel: ast::Decl = {
    <import: Import> SEMI => ast::Decl::Import(import),
    <export: Export> SEMI => ast::Decl::Export(export),

    <opaque: Opaque> SEMI => ast::Decl::Local(ast::LocalDecl::Opaque(opaque)),

    <enum_decl: EnumDecl> => ast::Decl::Local(ast::LocalDecl::Enum(enum_decl)),

    <struct_decl: StructDecl> => ast::Decl::Local(ast::LocalDecl::Struct(struct_decl)),

    <func: BuiltinFnDecl> SEMI => ast::Decl::Local(ast::LocalDecl::BuiltinFn(func)),

    <func: FnDecl> => ast::Decl::Local(ast::LocalDecl::Fn(func)),

    <ty: TypeDecl> => ast::Decl::Local(ast::LocalDecl::Type(ty)),
};

Ident: AstNode<ast::Ident> = {
    <nl: @L> <n: IDENT> <nr: @R> => ast_node!(ident!(n), nl, nr),
}

EnumDecl: AstNode<ast::EnumDecl> = {
    <l: @L> ENUM  <name: Ident> <type_params: TypeParams?> "{" <variants: EnumVariantList?> "}" <r: @R> => {
        let type_params = type_params.unwrap_or(ast::TypeParams { params: Vec::new() });
        let variants = variants.unwrap_or(vec![]);
        let (name, span) = name.into_data();
        let name = AstNode::new(name.into(), span);
        ast_node!(ast::EnumDecl {
            name,
            variants,
            type_params,
            annotations: Vec::new(),
        }, l, r)
    }
};

EnumVariantList: Vec<AstNode<ast::EnumVariant>> = {
    <v: EnumVariant> COMMA <mut rest: EnumVariantList> => {
        rest.insert(0, v);
        rest
    },

    <v: EnumVariant> => vec![v],
};

EnumVariant: AstNode<ast::EnumVariant> = {
    // TODO: annotations
    <l: @L> <n: IDENT> <r: @R> => {
        ast_node!(ast::EnumVariant::Unit {
            name: ast_node!(ident!(n).into(), l, r),
            annotations: vec![],
        }, l, r)
    },

    // TODO: annotations
    <l: @L> <n: IDENT> "{"<body: StructFieldList?> "}" <r: @R> => {
        let body = body.unwrap_or(vec![]);
        ast_node!(ast::EnumVariant::Struct {
            name: ast_node!(ident!(n).into(), l, r),
            body,
            annotations: vec![],
        }, l, r)
    },
};

TypeDecl: AstNode<ast::TypeDecl> = {
    <l: @L> TYPE <nl: @L> <name: IDENT> <nr: @R> EQ <ann: TypeAnn> <r: @R> => {
        ast_node!(ast::TypeDecl {
            name: ast_node!(ident!(name).into(), nl, nr),
            ann,
        }, l, r)
    }
};

FnDecl: AstNode<ast::FnDecl> = {
    <l: @L> FN <nl: @L> <name: IDENT> <nr: @R> <type_params: TypeParams?> <params: FnParams> <return_type: (ARROW TypeAnn)?>  <body: Block> <r: @R> => {
        let return_type = return_type.map(|rt| rt.1);
        let type_params = type_params.unwrap_or(ast::TypeParams { params: Vec::new() });
        ast_node!(ast::FnDecl {
            name: ast_node!(ident!(name).into(), nl, nr),
            params,
            return_type,
            type_params,
            body,
            annotations: Vec::new(),
            where_clause: None,
        }, l, r)
    }
};

BuiltinFnDecl: AstNode<ast::BuiltinFnDecl> = {
    <l: @L> BUILTIN FN <nl: @L> <name: IDENT> <nr: @R> <type_params: TypeParams?> <params: BuiltinFnParams> <return_type: (ARROW TypeAnn)?> <r: @R> => {
        let return_type = return_type.map(|rt| rt.1);
        let type_params = type_params.unwrap_or(ast::TypeParams { params: Vec::new() });
        ast_node!(ast::BuiltinFnDecl {
            name: ast_node!(ident!(name).into(), nl, nr),
            params,
            return_type,
            type_params,
            annotations: Vec::new(),
            where_clause: None,
        }, l, r)
    }
};

BuiltinFnParams: ast::BuiltinFnParams = {
    "(" UNCHECKED ")" => ast::BuiltinFnParams::Unchecked,
    <params: FnParams> => ast::BuiltinFnParams::Checked(params),
};

FnParams: Vec<AstNode<ast::FnParam>> = {
    "(" <list: FnParamList?> ")" => list.unwrap_or(Vec::new()),
};

FnParamList: Vec<AstNode<ast::FnParam>> = {
    <p: FnParam> COMMA <mut rest: FnParamList> => {
        rest.insert(0, p);
        rest
    },

    <p: FnParam> COMMA? => vec![p],
};

FnParam: AstNode<ast::FnParam> = {
    <nl: @L> <p: IDENT> <nr: @R>  COLON <ann: TypeAnn>  <rr: @R> => {
        ast_node!(ast::FnParam {
            name: ast_node!(ident!(p).into(), nl, rr),
            ann,
        }, nl, rr)
    }
};

// TODO: Where clause
StructDecl: AstNode<ast::Struct> = {
    <l: @L> STRUCT <nl: @L> <name: IDENT> <nr: @R> <type_params: TypeParams?> "{" <body: StructFieldList> "}" <r: @R> => {
        let type_params = type_params.unwrap_or(ast::TypeParams { params: Vec::new() });
        ast_node!(ast::Struct {
            name: ast_node!(ident!(name).into(), nl, nr),
            body,
            annotations: Vec::new(),
            type_params,
            where_clause: None,
        }, l, r)
    }
};

StructFieldList: Vec<ast::StructField> = {
    <f: StructField> COMMA <mut rest: StructFieldList> => {
        rest.insert(0, f);
        rest
    },

    <f: StructField> COMMA? => {
        vec![f]
    },
};

StructField: ast::StructField = {
    <nl: @L> <f: IDENT> <nr: @R> COLON <ann: TypeAnn> => {
        ast::StructField {
            name: ast_node!(ident!(f), nl, nr),
            field_type: ann,
        }
    }
};

TypeAnn: AstNode<ast::TypeAnn> = {
    <l: @L> <tp: TypedPath> <r: @R> => ast_node!(ast::TypeAnn::Path(tp), l, r),
    <l: @L> <ft: FnType> <r: @R> => ast_node!(ast::TypeAnn::FnType(ft), l, r),
};

FnType: AstNode<ast::FnType> = {
    <l: @L> FN "(" <params: TypeArgsList?> ")" ARROW <return_type: TypeAnn> <r: @R> => {
        let params = params.unwrap_or(Vec::new());
        let return_type = Some(Box::new(return_type));
        ast_node!(ast::FnType {
            params,
            return_type,
        }, l, r)
    }
}

TypedPath: AstNode<ast::TypedPath> = {
    <l: @L> <base: ModulePath> <args: TypeArgs?> <r: @R> => {
        let args = args.unwrap_or(Vec::new());
        ast_node!(ast::TypedPath {
            base,
            args
        }, l, r)
    }
};

TypeArgs: Vec<AstNode<ast::TypeAnn>> = {
    "[" <l: TypeArgsList>  "]" => l,
};

TypeArgsList: Vec<AstNode<ast::TypeAnn>> = {
   <t: TypeAnn> COMMA <mut rest: TypeArgsList> => {
        rest.insert(0, t);
        rest
    },

    <t: TypeAnn> COMMA? => vec![t],
};

ModulePath: AstNode<ast::ModulePath> = {
    <l: @L> <i: IDENT> <r: @R> COLONCOLON <rest: ModulePath> <rr: @R> => {
        let (mut data, _) = rest.into_data();
        data.0.insert(0, ast_node!(ident!(i).into(), l, r));
        ast_node!(data, l, rr)
    },

    <l: @L> <i: IDENT> <r: @R> => {
        ast_node!(ast::ModulePath(vec![ast_node!(ident!(i).into(), l, r)]), l, r)
    },
};


// TODO: Where clause
Opaque: AstNode<ast::Opaque> = {
    <l: @L> OPAQUE <nl: @L> <name: IDENT><nr: @R> <type_params: TypeParams?> <r: @R>=> {
        let type_params = type_params.unwrap_or(ast::TypeParams { params: Vec::new() });
        ast_node!(ast::Opaque {
            name: ast_node!(ast::Name::from(ident!(name)), nl, nr),
            annotations: Vec::new(),
            type_params,
            where_clause: None,
        }, l, r)
    }
};

TypeParams: ast::TypeParams = {
     "[" <tps: TypeParamList> "]" => ast::TypeParams { params: tps },
};

TypeParamList: Vec<AstNode<ast::Name>> = {
    <l: @L> <tp: IDENT> <r: @R> COMMA <mut rest: TypeParamList> => {
        rest.insert(0, ast_node!(ident!(tp).into(), l, r));
        rest
    },

    <l: @L> <tp: IDENT> <r: @R> COMMA? => vec![ast_node!(ident!(tp).into(), l, r)],
};

Export: AstNode<ast::ExportDecl> = {
    // export all from module [except { List<ModuleItemData> }]?
    <l: @L> EXPORT ALL FROM <module: ModuleInst> <except: (EXCEPT "{" ModuleItemDataList "}")?> <r: @R> => {
        let except: Vec<AstNode<ast::ModuleItemData>> = except.map(|e| e.2)
            .unwrap_or(Vec::new());
        ast_node!(ast::ExportDecl::ExportAll {
            from_module: Some(module),
            except,
        }, l, r)
    },

    // TODO: unify when locations can be extracted within non-top-levels
    // export all [except { List<ModuleItemData> }]?
    <l: @L> EXPORT ALL <except: (EXCEPT "{" ModuleItemDataList "}")?> <r: @R>=> {
        let except: Vec<AstNode<ast::ModuleItemData>> = except.map(|e| e.2)
            .unwrap_or(Vec::new());
        ast_node!(ast::ExportDecl::ExportAll {
            from_module: None,
            except,
        }, l, r)
    },

    // export from module { List<ModuleItemData> }
    <l: @L> EXPORT FROM <module: ModuleInst> "{" <items: ModuleItemDataList > "}" <r: @R> => {
        ast_node!(ast::ExportDecl::ExportItems {
            from_module: Some(module),
            items,
        }, l, r)
    },

    // export { List<ModuleItemData> }
    <l: @L> EXPORT "{" <items: ModuleItemDataList> "{" <r: @R> => {
        ast_node!(ast::ExportDecl::ExportItems {
            from_module: None,
            items,
        }, l, r)
    },
};

Import: AstNode<ast::ImportDecl> = {

    // import module { List<module-item-data> } from module
    <il: @L> IMPORT "{" <items: ModuleItemDataList> "}" FROM <module: ModuleInst> <r: @R> => {
        ast_node!(ast::ImportDecl::ImportItems {
            module,
            items,
        }, il, r)
    },

    // import module
    <l: @L> IMPORT <module: ModuleInst> <r: @R> => {
        ast_node!(ast::ImportDecl::ImportModule {
            module,
            alias: None,
        }, l, r)
    },

    // TODO: combine with the other rule somehow?
    // import module as module_alias
    <l: @L> IMPORT <module: ModuleInst> AS <l2: @L> <alias: IDENT> <r2: @R> => {
        ast_node!(ast::ImportDecl::ImportModule {
            module,
            alias: Some(ast_node!(ident!(alias), l2, r2)),
        }, l, r2)
    },

    // import all from module [except { List<module-item-data> }]?
    <l: @L> IMPORT ALL FROM <module: ModuleInst> <except: (EXCEPT "{" ModuleItemDataList "}")?> <r: @R>=> {
        let except: Vec<AstNode<ast::ModuleItemData>> = except.map(|e| e.2)
            .unwrap_or(Vec::new());
        ast_node!(ast::ImportDecl::ImportAll {
            module,
            except,
        }, l, r)
    },
};

ModuleInst: AstNode<ast::ModuleInst> = {
    <l: @L> <m: ModulePath> <r: @R> => ast_node!(ast::ModuleInst { module: m, args: vec![] }, l, r),

    <l: @L> <m: ModulePath> "(" <args: ModuleInstList?> ")" <r: @R> => {
        let args = args.unwrap_or(vec![]);
        ast_node!(ast::ModuleInst {
            module: m,
            args,
        }, l, r)
    },
};

ModuleInstList: Vec<AstNode<ast::ModuleInst>> = {
    <f: ModuleInst> COMMA <mut rest: ModuleInstList> => {
        rest.insert(0, f);
        rest
    },

    <f: ModuleInst> COMMA? => vec![f],
};

ModuleItemDataList: Vec<AstNode<ast::ModuleItemData>> = {
    // ModuleItemData , ModuleItemDataList
    <d: ModuleItemData> COMMA <mut rest: ModuleItemDataList> => {
        rest.insert(0, d);
        rest
    },

    // ModuleItemData [,]?
    <d: ModuleItemData> COMMA? => vec![d],
};

ModuleItemData: AstNode<ast::ModuleItemData> = {
    // item as item_alias
    <l1: @L> <item: IDENT> <r1: @R> AS <l2: @L> <alias: IDENT?> <r2: @R> => {
        ast_node!(ast::ModuleItemData {
            original_name: AstNode::new(ident!(item).into(), Span::new(l1, r1)),
            name_override: alias.map(|i| AstNode::new(ident!(i).into(), Span::new(l2, r2))),
        }, l1, r2)
    },

    // item
    <l: @L> <item: IDENT> <r: @R> => {
        ast_node!(ast::ModuleItemData {
            original_name: ast_node!(ident!(item).into(), l, r),
            name_override: None,
        }, l, r)
    },
};

// exprs / stmts
Block: AstNode<east::Block> = {
    <l: @L> "{" <imports: (Import SEMI)*> <block: BlockList?> "}" <r: @R> => {
        let (stmts, return_expr) = block.unwrap_or((vec![], None));
        let block = east::Block {
            imports: imports.into_iter().map(|(import, _semi)| import).collect(),
            stmts,
            return_expr,
        };

        ast_node!(block, l, r)
    },
};

BlockList: (Vec<east::Stmt>, Option<Box<east::Expr>>) = {
    <stmt: Stmt> <mut block: BlockList> => {
        block.0.insert(0, stmt);
        block
    },

    BlockEnd,
};

BlockEnd: (Vec<east::Stmt>, Option<Box<east::Expr>>) = {
    <stmt: SafeStmt> => (vec![stmt], None),
    <expr: Expr> => (vec![], Some(Box::new(expr))),
};

Stmt: east::Stmt = {
    <if_stmt: IfExpr> => east::Stmt::If(if_stmt),

    <while_stmt: WhileExpr> => east::Stmt::While(while_stmt),

    <b: Block> => east::Stmt::Block(b),

    SafeStmt,
};

// Rule hack to get block return expressions to work
SafeStmt: east::Stmt = {

    <let_stmt: LetStmt> => east::Stmt::Let(let_stmt),

    <l: @L> RETURN <e: Expr?> SEMI <r: @R> => east::Stmt::Return(ast_node!(east::ReturnStmt { expr: e }, l ,r)),

    <l: @L> CONTINUE SEMI <r: @R> => east::Stmt::Continue(ast_node!(east::ContinueStmt, l, r)),

    <l: @L> BREAK <e: Expr?> SEMI <r: @R> => east::Stmt::Break(ast_node!(east::BreakStmt { expr: e }, l, r)),

    <l: @L> EXTRACT <e: Expr?> SEMI <r: @R> => east::Stmt::Extract(ast_node!(east::ExtractStmt { expr: e }, l, r)),

    <expr_stmt: Expr> SEMI => east::Stmt::ExprStmt(expr_stmt),

};

// TODO: add patterns
LetStmt: AstNode<east::LetStmt> = {
    <l: @L> LET <pl: @L> <name: IDENT> <pr: @R> <type_ann: (COLON TypeAnn)?> EQ <init: Expr> SEMI <r: @R> => {
        ast_node!(east::LetStmt {
            name: ast_node!(ident!(name).into(), pl, pr),
            type_ann: type_ann.map(|ta| ta.1),
            init,
        }, l, r)
    }
};

Expr: east::Expr = {
    <l: @L> <left: PipeExpr> <opl: @L> EQ <opr: @R> <right: Expr> <r: @R>=> {
        east::Expr::Bin(ast_node!(east::BinExpr {
            op: ast_node!(east::BinOp::Assign, opl, opr),
            left: Box::new(left),
            right: Box::new(right),
        }, l, r))
    },

    PipeExpr,
};

PipeExpr = {
    <l: @L> <left: PipeExpr> <opl: @L> ARROW <opr: @R> <right: PipableExpr> <r: @R> => {
        east::Expr::Bin(ast_node!(east::BinExpr {
            op: ast_node!(east::BinOp::Pipe, opl, opr),
            left: Box::new(left),
            right: Box::new(right),
        }, l, r))
    },

    PipableExpr,
};

PipableExpr: east::Expr = {

    <b: Block> => east::Expr::Block(b),

    <if_expr: IfExpr> => east::Expr::If(Box::new(if_expr)),

    <while_expr: WhileExpr> => east::Expr::While(Box::new(while_expr)),

    InfixExpr,
};

InfixExpr: east::Expr = {

     <l: @L> <left: InfixExpr> <op: InfixOp> <right: UniExpr> <r: @R> => {
        east::Expr::Bin(ast_node!(east::BinExpr {
            op,
            left: Box::new(left),
            right: Box::new(right),
        }, l, r))
    },

    UniExpr,
};

InfixOp: AstNode<east::BinOp> = {
    <l: @L> AND <r: @R> => ast_node!(east::BinOp::And, l, r),
    <l: @L> OR <r: @R> => ast_node!(east::BinOp::Or, l, r),
};

UniExpr: east::Expr = {

    <l: @L> <op: UniOp> <expr: UniExpr> <r: @R> => {
        east::Expr::Uni(ast_node!(east::UniExpr {
            op,
            expr: Box::new(expr),
        }, l, r))
    },

    AppExpr,
};

AppExpr: east::Expr = {

    <fn_call: FnCall> => east::Expr::FnCall(fn_call),
    <dot_access: DotAccess> => east::Expr::DotAccess(dot_access),

    ExprLeaf,
};

ExprLeaf: east::Expr = {

    <lambda: Lambda> => east::Expr::Lambda(lambda),

    <literal: Literal> => east::Expr::Literal(literal),

    <path: TypedPath> => east::Expr::Path(path),

    <init: StructInit> => east::Expr::StructInit(init),

    // underscore (only usable as immediate children of fn calls)
    <l: @L> UNDERSCORE <r: @R> => east::Expr::Underscore(ast_node!((), l, r)),

    "(" <e: Expr> ")" => e,
};

DotAccess: AstNode<east::DotAccess> = {
    <l: @L>< root: AppExpr> DOT <fl: @L> <field: IDENT> <r: @R> => {
        ast_node!(east::DotAccess {
            base: Box::new(root),
            field: ast_node!(ident!(field).into(), fl, r),
        }, l, r)
    }
};

Lambda: AstNode<east::Lambda> = {
    <l: @L> LAM <params: LambdaParams> <return_type: (ARROW TypeAnn)?> COLON <body: Block> <r: @R> => {
        ast_node!(east::Lambda {
            body: Box::new(east::Expr::Block(body)),
            params,
            return_type: return_type.map(|rt| rt.1),
        }, l, r)
    }
};

LambdaParams: Vec<AstNode<east::LambdaParam>> = {
    "(" <list: LambdaParamList?> ")" => list.unwrap_or(Vec::new()),
};

LambdaParamList: Vec<AstNode<east::LambdaParam>> = {
    <p: LambdaParam> COMMA <mut rest: LambdaParamList> => {
        rest.insert(0, p);
        rest
    },

    <p: LambdaParam> COMMA? => vec![p],
};

LambdaParam: AstNode<east::LambdaParam> = {
    <l: @L> <p: IDENT> <r: @R> => ast_node!(east::LambdaParam {
        name: ast_node!(ident!(p).into(), l, r),
        ann: None,
    }, l , r),

    <fp: FnParam> => {
        let (data, span) = fp.into_data();
        AstNode::new(east::LambdaParam {
            name: data.name,
            ann: Some(data.ann),
        }, span)
    },
};

StructInit: AstNode<east::StructInit> = {
    <l: @L> INIT <struct_name: TypedPath?> "{" <init: StructFieldInitList?> "}" <r: @R> => {
        let field_init = init.unwrap_or(Vec::new());
        ast_node!(east::StructInit {
            struct_name,
            field_init: field_init,
        }, l, r)
    },
};

StructFieldInitList: Vec<(AstNode<ast::Ident>, Box<east::Expr>)> = {
    <init: StructFieldInit> COMMA <mut rest: StructFieldInitList> => {
        rest.insert(0, init);
        rest
    },

    <init: StructFieldInit> COMMA => vec![init],
};

StructFieldInit: (AstNode<ast::Ident>, Box<east::Expr>) = {
    <l: @L> <field: IDENT> <r: @R> COLON <e: Expr> => {
        (ast_node!(ident!(field), l, r), Box::new(e))
    }
};

FnCall: AstNode<east::FnCall> = {
    <l: @L> <func: AppExpr> "("<list: ArgList?> ")" <r: @R> => {
        let func = Box::new(func);
        let args = list.unwrap_or(Vec::new());
        ast_node!(east::FnCall {
            func,
            args,
        }, l, r)
    },
};

ArgList: Vec<east::Expr> = {
    <e: Expr> COMMA <mut rest: ArgList> => {
        rest.insert(0, e);
        rest
    },

    <e: Expr> COMMA? => vec![e],
}

UniOp: east::UniOp = {
    AMP => east::UniOp::Ref,
    AT => east::UniOp::Deref,
    BANG => east::UniOp::Not,
};

Literal: AstNode<east::Literal> = {
    <l: @L> <literal: STRING> <r: @R> => ast_node!(east::Literal::String(literal_data!(literal => string)), l, r),

    <l: @L> <literal: FLOAT> <r: @R> => ast_node!(east::Literal::Float(literal_data!(literal => float)), l, r),

    <l: @L> <literal: INT> <r: @R> => ast_node!(east::Literal::Int(literal_data!(literal => int)), l, r),

    <l: @L> <literal: BOOL> <r: @R> => {
        match literal {
            tokens::Token::BoolLiteral(literal) => ast_node!(east::Literal::Bool(literal), l, r),
            _ => unreachable!(),
        }
    }
};

WhileExpr: AstNode<east::While> = {
    <l: @L> WHILE <main_cond: Expr> <main_body: Block>  <elifs: (ELIF Expr Block)*> <default_branch: (ELSE Block)?> <r: @R> => {

        let elifs = elifs.into_iter().map(|elif|
            east::Branch {
                condition: elif.1,
                block: elif.2,
            });
        let main_branch = east::Branch {
            condition: main_cond,
            block: main_body,
        };
        let default_branch = default_branch.map(|e| e.1);
        let branches = std::iter::once(main_branch).chain(elifs).collect();

        ast_node!(east::While {
            branches,
            default_branch,
        }, l, r)
    }
};

IfExpr: AstNode<east::If> = {
    <l: @L> IF <main_cond: Expr> <main_branch: Block> <elifs: (ELIF Expr Block)*> <default_branch: (ELSE Block)?> <r: @R> => {

        let elifs = elifs.into_iter().map(|elif|
            east::Branch {
                condition: elif.1,
                block: elif.2,
            });
        let main_branch = east::Branch {
            condition: main_cond,
            block: main_branch,
        };
        let default_branch = default_branch.map(|e| e.1);
        let branches = std::iter::once(main_branch).chain(elifs).collect();

        ast_node!(east::If {
            branches,
            default_branch,
        }, l, r)
    }
};

extern {
    type Location = usize;
    type Error = error::SpannedError;

    enum tokens::Token {
        IDENT => tokens::Token::Ident(..),

        STRING => tokens::Token::StringLiteral(..),
        INT => tokens::Token::IntLiteral(..),
        FLOAT => tokens::Token::FloatLiteral(..),
        BOOL => tokens::Token::BoolLiteral(..),

        SIG => tokens::Token::Sig,
        MOD => tokens::Token::Mod,
        TYPE => tokens::Token::Type,
        MVAL => tokens::Token::MVal,

        FN => tokens::Token::Fn,
        ENUM => tokens::Token::Enum,
        STRUCT => tokens::Token::Struct,
        OPAQUE => tokens::Token::Opaque,
        USE => tokens::Token::Use,
        BUILTIN => tokens::Token::Builtin,
        UNCHECKED => tokens::Token::Unchecked,
        WHERE => tokens::Token::Where,
        COMMA => tokens::Token::Comma,
        ARROW => tokens::Token::Arrow,
        COLON => tokens::Token::Colon,
        COLONCOLON => tokens::Token::ColonColon,
        SEMI => tokens::Token::Semi,
        POUND => tokens::Token::Pound,
        BASE => tokens::Token::Base,

        IMPORT => tokens::Token::Import,
        EXPORT => tokens::Token::Export,
        EXCEPT => tokens::Token::Except,
        FROM => tokens::Token::From,
        ALL => tokens::Token::All,
        AS => tokens::Token::As,

        INIT => tokens::Token::Init,
        LAM => tokens::Token::Lam,
        UNDERSCORE => tokens::Token::Underscore,
        EXTRACT => tokens::Token::Extract,
        CONTINUE => tokens::Token::Continue,
        BREAK => tokens::Token::Break,
        RETURN => tokens::Token::Return,
        IF => tokens::Token::If,
        ELSE => tokens::Token::Else,
        ELIF => tokens::Token::Elif,
        WHILE => tokens::Token::While,
        LET => tokens::Token::Let,
        EQEQ => tokens::Token::EqEq,
        BANGEQ => tokens::Token::BangEq,
        EQ => tokens::Token::Eq,
        DOT => tokens::Token::Dot,
        AT => tokens::Token::At,
        AMP => tokens::Token::Amp,
        PIPE => tokens::Token::Pipe,
        BANG => tokens::Token::Bang,
        AND => tokens::Token::And,
        OR => tokens::Token::Or,
        PLUS => tokens::Token::Plus,
        IMPL => tokens::Token::Impl,
        "(" => tokens::Token::LParen,
        ")" => tokens::Token::RParen,
        "[" => tokens::Token::LBracket,
        "]" => tokens::Token::RBracket,
        "{" => tokens::Token::LBrace,
        "}" => tokens::Token::RBrace,
    }
}
